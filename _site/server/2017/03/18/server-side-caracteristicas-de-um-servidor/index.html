<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Blog de tecnologia e desenvolvimento — artigos, tutoriais e opinião.">

    <title>Server-side: características de um servidor - A odisseia do puto</title>

    <link rel="canonical" href="http://localhost:4000/server/2017/03/18/server-side-caracteristicas-de-um-servidor/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/clean-blog.css">
    <link rel="stylesheet" href="/css/odisseia.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
    
    <!-- Share CSS -->
    <link rel="stylesheet" href="/css/share.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="A odisseia do puto" />

    

</head>


<body>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">A odisseia do puto</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
				
                <li>
                    <a href="/about/">Sobre</a>
                </li>
				
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


    <!-- Post Header -->
<header class="intro-header">
    <div class="intro-header-overlay">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>Server-side: características de um servidor</h1>
                        
                        <h2 class="subheading">Um pouco sobre a arquitetura dos servidores</h2>
                        
                        <span class="meta">Postado por Ronaldo Faria Lima em 18/03/2017</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="share">
  <li><a href="https://twitter.com/intent/tweet?text=Server-side: características de um servidor&url=http://localhost:4000/server/2017/03/18/server-side-caracteristicas-de-um-servidor/" rel="nofollow" target="_blank" title="Share on Twitter"><i class="fa fa-twitter-square"></i></a></li>
  <li><a href="https://facebook.com/sharer.php?u=http://localhost:4000/server/2017/03/18/server-side-caracteristicas-de-um-servidor/" rel="nofollow" target="_blank" title="Share on Facebook"><i class="fa fa-facebook-square"></i></a></li>
  <li><a href="http://www.linkedin.com/shareArticle?mini=true&url=http://localhost:4000/server/2017/03/18/server-side-caracteristicas-de-um-servidor/" rel="nofollow" target="_blank" title="Share on Linkedlin"><i class="fa fa-linkedin-square"></i></a></li>
  <li><a href="https://plus.google.com/share?url=http://localhost:4000/server/2017/03/18/server-side-caracteristicas-de-um-servidor/" rel="nofollow" target="_blank" title="Share on Google+"><i class="fa fa-google-plus-square"></i></a></li>
</ul>

				<h1 id="antes-de-começar">Antes de começar</h1>

<p>Este artigo trata, basicamente, de características do sistema operacional. Pode
parecer um pouco fora dos assuntos do EquinociOS, mas é algo bastante
relevante. Desde que a Apple liberou a linguagem Swift como um projeto de
código-aberto, muita gente vem usando a linguagem para desenvolver software do
lado do servidor. Assim, torna-se bastante relevante o conhecimento que é
apresentado neste artigo pois o software servidor executa em um ambiente que
fará algumas exigências para o seu correto funcionamento.</p>

<p>É importante ter em mente que o ambiente no qual seu software executa precisa
ser respeitado. Este ambiente proporcionará vantagens, e também desvantagens,
que precisam ser entendidas e avaliadas. O intuito é integrar bem o seu software
com este ambiente e tirar proveito das vantagens evitando-se as desvantagens.</p>

<p>Considerando-se que o software do lado do servidor normalmente funciona em
esquema 24 x 7 x 365, a boa integração com o ambiente aumenta bastante a
confiabilidade e a robustez. Portanto, é importante conhecer, mesmo que
superficialmente, o ambiente de execução do seu servidor.</p>

<h1 id="o-que-é-o-servidor">O que é o servidor?</h1>

<p>O conceito de servidor não é novo. Apareceu na série 360 da IBM em 1964. Desde
então vem sofrendo transformações até chegar no modelo em nuvem conforme temos
hoje. Mas, o que raios é o servidor?</p>

<p>Olhando pela ótica do software, que é a premissa deste artigo, o servidor é um
artefato de software cuja função é prover serviços à outros artefatos de
software, chamados de <em>clientes</em>. Esta não é uma definição formal nem muito
menos precisa. A intenção é partirmos desta definição para entender como
projetar um servidor de software de maneira a usar as principais características
do sistema operacional no qual estará hospedado.</p>

<p>Hoje em dia o papel principal do servidor é prover serviços a clientes leves, ou
<em>thin clients</em>, normalmente aplicativos para celulares. Todo o processamento
pesado e o armazenamento fica por conta do servidor, deixando o cliente com a
tarefa de organizar, logicamente, os fluxos de trabalho disponíveis para que o
usuáio seja atendido em determinada funcionalidade.</p>

<p>O servidor pode ser uma ou mais peças de software trabalhando em conjunto,
formando um sistema que pode ser agregado ou distribuído. Para o cliente, o
servidor é um só, mesmo que sejam várias máquinas físicas diferentes, vários
sistemas de software criados por várias linguagens diferentes, interagindo entre
si através das mais diversas formas de integração.</p>

<h1 id="linux-e-unix">Linux e Unix</h1>

<p>Nos dias de hoje o sistema operacional mais popular para <em>back-end</em> é, sem
dúvida, o Linux. O Unix é um sistema muito popular no ambiente corporativo,
apesar das vendas deste sistema decrescer ano após ano. Sendo rigoroso, o Unix
não é Linux e Linux não é Unix. São sistemas completamente diferentes, apesar
das suas similaridades.</p>

<p>Apesar do foco deste artigo ser o Linux, os princípios e conceitos aqui
apresentados valem para o Unix. Vale lembrar que o FreeBSD é um Unix e não
Linux. A camada de compatibilidade entre o BSD e o Linux é tão boa e
transparente que ela faz com que praticamente tudo o que executa em um sistema
seja executado em outro.</p>

<p>De toda forma vou intercambiar os termos Unix e Linux ao longo do texto,
tratando tudo como se fosse Unix por questão de simplicidade. Se houver algo que
seja inerente a um sistema, deixarei explícito para que não haja confusões.</p>

<p>Vamos começar por alguns conceitos básicos que serão usados através do restante
do texto. Com o intuito de equalizar o conhecimento, apresento de forma bastante
rápida estes conceitos.</p>

<h2 id="daemon">Daemon</h2>

<p>Apesar do termo lembrar os demônios cristãos, ou seja, entidades malévolas, o
termo <em>daemon</em> foi emprestado do termo grego <em>daimon</em> que refere-se a entidades
naturais benignas e que estão sempre presentes em nossas vidas.</p>

<p>A despeito da questão religiosa, um <em>daemon</em> é, na verdade, um processo autônomo
que é executado em segundo plano, fornecendo ou executando algum tipo de
serviço. Normalmente os daemons no Unix/Linux são processos iniciados durante a
carga do sistema, através de um sistema de inicialização como o System V ou o
upstart do Ubuntu.</p>

<p>Uma vez iniciados, estes processos normalmente terminam quando o sistema é
reiniciado, ou seja, são processos de execução longa, projetados para
permanecerem funcionando por longos períodos de tempo.</p>

<h2 id="ipc">IPC</h2>

<p>IPC é uma sigla que significa <em>Inter-Process Communication</em>. Tanto o Unix quanto
o Linux implementam várias formas de comunicação inter-processo:</p>

<ul>
  <li><em>pipes</em> para escrita e leitura síncrona de dados;</li>
  <li><em>message queues</em> para escrita e leitura assíncrona de dados;</li>
  <li><em>semáforos</em> para o controle atômico de recursos compartilhados;</li>
  <li><em>shared memory</em> para compartilhamento de arenas de memória;</li>
  <li><em>sockets</em>, em particular os sockets Unix, para troca assíncrona de dados
arbitrários;</li>
  <li><em>sinalização</em>, usado para entregar eventos a processos arbitrários.</li>
</ul>

<p>Muitos autores não consideram a sinalização como parte do IPC. No entanto, é uma
característica importante do sistema operacional pois é através dos sinais que o
sistema de inicialização comunica-se com os deamons.</p>

<p>Os sinais são eventos assíncronos que podem, ou não, ser capturados e tratados
por um processo. Apesar dos sinais serem números inteiros, eles são limitados
pelo sistema operacional. Os sinais são definidos no arquivo de cabeçalho
<em>signal.h</em>, que normalmente está no diretório <code class="language-plaintext highlighter-rouge">/usr/include</code>.</p>

<h2 id="system-calls">System Calls</h2>

<p>Sempre que seu programa precisa interagir com o sistema operacional ele fará uma
chamada de sistema, ou <em>system call</em>. Mesmo que você não o faça diretamente,
algumas operações sempre terminam em uma chamada de sistema, como alocação de
memória, abertura e escrita em arquivos, comunicação por rede e por aí vai.</p>

<p>As chamadas de sistema são muito importantes pois permitem que o seu software
interaja com o kernel do sistema operacional, trazendo uma série de vantagens
importantes no que tange a integração de sistemas.</p>

<h2 id="linguagem-c">Linguagem C</h2>

<p>Por que coloco a linguagem C na lista de definições? A resposta é muito simples:
tanto o Unix quanto o Linux são sistemas operacionais escritos em C. Os <em>system
calls</em> são todos escritos em C e são acessados através de bibliotecas escritas
em C do próprio sistema operacional. Assim, é impossível falar em Linux e Unix
sem mencionar esta linguagem.</p>

<p>Para quem programa em Swift e deseja criar software do lado do servidor aqui vai
a primeira dica: se você não sabe C, procure aprender. Infelizmente Swift não
possui, nativamente, uma forma de realizar chamadas de sistema. A captura de
sinais, criação de processos-filhos e outras características do sistema
operacional só são conseguidas se você interfacear seu código Swift com wrappers
escritos em C.</p>

<p>Na plataforma Apple a integração é quase <em>out-of-the-box</em> ao importar-se o
módulo <em>Darwin</em>. Porém, muita coisa importante fica de fora. Além disso, as
bibliotecas da Apple acabam se tornando um estorvo. Por exemplo, a função
<em>sigaction</em> usa uma estrutura como um dos parâmetros para instalação de handlers
de sinal. No caso da Apple, esta estrutura contém uma união que é mascarada por
macros. Para a linguagem C isso é irrelevante, mas para o Swift, faz toda a
diferença. O código Swift neste caso, compilará para a plataforma Apple se a
estrutura for usada conforme definida, e falhará para o Linux. A recíproca é
totalmente verdadeira, ou seja, o código feito para Linux não compilará na
plataforma Apple. É necessário, portanto, fazer um wrapper em C para permitir o
funcionamento <em>cross platform</em>.</p>

<h2 id="processo">Processo</h2>

<p>Sempre que um executável entra em execução no Unix e no Linux, ele cria um
<em>processo</em>. O processo é uma instância de execução do seu executável. Em linhas
gerais, o mesmo executável pode ter diversas instâncias de execução, podendo ser
chamado quantas vezes o usuário bem desejar. A cada instância de execução é
asssociado um número inteiro que identifica este processo para o sistema
operacional. Este número é chamado de <em>PID</em>, de <em>process identification</em>. A
estrutura de numeração de processos nos sistemas operacionais Unix e Linux é uma
lista circular. Isto é feito para que os números de processo sejam
reaproveitados. Assim, o processo criado para um determinado executável pode ter
atribuído um número inteiro qualquer, repetindo-se ou não.</p>

<p>Normalmente o processo cujo PID é 1 é o processo de inicialização do sistema, o
processo que é pai de todo mundo, chamado de <em>init</em>. Tudo no Unix e Linux é
iniciado pelo <em>init</em>. Os usuários, quando autenticados e conectados a estes
sistemas utilizam processos que foram inicialmente criados pelo init, mas que
deram origem a outros processos.</p>

<h3 id="processo-filho">Processo-filho</h3>

<p>O processo-filho é um processo que é criado por outro processo. O processo-filho
tem como característica um número inteiro chamado de <em>PPID</em>, ou <em>parent process
ID</em>. O processo-pai pode ser um processo-filho de outro processo e este fato
implica na criação de uma árvore de processos.</p>

<p>As implicações disso são importantes para o correto design de um software do
lado do servidor, conforme veremos a seguir.</p>

<h1 id="daemons-e-o-init">Daemons e o init</h1>

<p>Um daemon é um programa comum, como qualquer outro, porém com ciclo longo de
execução. Normalmente, o daemon executa apenas uma única instância na máquina
onde está hospedado. Via de regra, os daemons são iniciados pelo sistema de
inicialização do Unix, podendo ser um sistema baseado no System V ou em outra
forma de inicialização. Normalmente os sistemas Linux têm maneiras um pouco
diferentes de inicialização, como o ubuntu que está movendo-se para o <em>upstart</em>,
um sistema de inicialização um pouco mais eficiente e mais flexível que o antigo
System V.</p>

<p>O sistema de inicialização não é, na verdade, importante para os propósitos
deste texto. O fato é que todo daemon pode ser iniciado pelo init e a
inicialização garante que o processo iniciado não estará associado a nenhum
terminal. E aqui começamos a ver o que é realmente importante ter no seu
processo do lado do servidor para que ele intereja de forma adequada com o
sistema operacional.</p>

<h2 id="sinalização">Sinalização</h2>

<p>Uma das formas que o sistema de inicialização tem de comunicar-se com o seu
software é através do envio de sinais. Os sinais são números inteiros e cada
número tem seu significado. A listagem de sinais normalmente é compilada através
de um conjunto de macros declarados em <em>signal.h</em>. Este arquivo normalmente
reside no diretório <code class="language-plaintext highlighter-rouge">/usr/include</code>.</p>

<p>A sinalização ocorre de maneira assíncrona e interrompe qualquer que seja o
fluxo em execução no seu programa, retomando ao ponto de interrupção tão logo o
sinal seja tratado ou ignorado. É importante ter em mente, no entanto, que nem
todo sinal pode ser tratado. Alguns sinais, em especial <code class="language-plaintext highlighter-rouge">SIGKILL</code>, não podem ser
capturados nem tratados pelo seu software. O seu comportamento acaba sendo
definido pelo sistema operacional. Por exemplo, <code class="language-plaintext highlighter-rouge">SIGKILL</code> elimina o processo que
executa o seu software da memória, não importa o que o seu software esteja
fazendo. Este é um dos sinais que não podem ser nem capturados nem tratados.</p>

<h3 id="sinais-notáveis">Sinais notáveis</h3>

<p>Alguns sinais são importantes pois são usados com frequência pelos sistemas de
inicialização e controle de processos. Em particular os sinais <code class="language-plaintext highlighter-rouge">SIGTERM</code> e
<code class="language-plaintext highlighter-rouge">SIGHUP</code> são usados para terminar ou reiniciar um daemon, respectivamente. Assim
é importante capturar e tratar <code class="language-plaintext highlighter-rouge">SIGTERM</code>para que seu daemon seja finalizado de
forma graciosa; e <code class="language-plaintext highlighter-rouge">SIGHUP</code> para que seu processo possa reiniciar-se, ou seja,
recarregar a configuração e iniciar do zero, como se estivesse sendo carregado
pela primeira vez.</p>

<p>Ao capturar e tratar os sinais <em>notáveis</em> você estará melhorando a integração do
seu software com sistemas Unix, tornando-o mais adequado para uso com os
sistemas de inicialização, seja System V ou seja via upstart.</p>

<h2 id="daemonização">Daemonização</h2>

<p>Se você abrir um terminal, seja um Xterm, ou um terminal de texto pendurado a
uma linha serial, qualquer processo que você iniciar manualmente estará
associado ao seu terminal. Este é um trabalho que o kernel faz no intuito de
finalizar qualquer processo caso seu terminal seja desconectado. Esta
característica é boa e não é.</p>

<p>O fato é que pode ser necessário reiniciar um daemon manualmente. Digamos que
seja necessário realizar uma manutenção no servidor, por algum motivo. Portanto,
é imperativo que seu daemon não esteja associado com o seu terminal pois, se
estiver, ao fechar o seu terminal o processo cai.</p>

<p>Os sistemas de inicialização já garantem que o seu daemon seja executado
dissociado de um terminal. Porém, a daemonização pode auxiliá-no no design do
seu daemon simplificando uma série de coisas, como a reinicialização <em>a quente</em>
do seu processo, conforme expliquei na seção sobre sinais notáveis.</p>

<p>Normalmente você vai iniciar o seu daemon através do sistema de inicialização,
via <em>start</em>, <em>initctl</em> ou algum comando especial que reside no <em>/sbin</em> ou
<em>/usr/sbin</em> dependendo do seu Unix ou Linux.</p>

<p>A daemonização consiste em dissociar seu processo do seu terminal ativo. Isto é
algo muito simples de ser feito, na realidade. A ideia por trás disso é criar um
processo-filho e o processo-filho criar outro processo-filho que, em última
instância, executará o código do seu daemon, tomando-se o cuidado de terminar os
processos-pai sem aguardar o retorno dos processos-filhos.</p>

<p>Neste cenário o processo neto é adotado pelo sistema de inicialização e
torna-se, efetivamente, dissociado do seu terminal. Isto é tão simples de ser
realizado que dá para fazer num shell script:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{ { a=0; while [ $a -lt 10 ]; do sleep 10; a=$((a+1)); echo "Executado $a vezes" &gt;&gt; $HOME/output.txt; done }&amp; }&amp;
</code></pre></div></div>

<p>Este comando meio esquisito inicia um contador que escreve um arquivo texto a
cada 10 segundos, durante 100 segundos. Se antes de finalizar o script você
fechar o seu terminal o arquivo <em>output.txt</em> continuará a crescer.</p>

<p>O truque é bem simples: cria-se um processo-filho e dentro deste processo-filho
cria-se outro processo-filho. Em C, teríamos algo assim usando a forma clássica
de criação de processos-filho:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (fork() == 0) {
    if (fork() == 0) {
        /* Aqui vai o seu processo. Este é o processo-neto */
    } else {
        /* Termina o processo-fiho sem esperar o sincronismo */
        exit(0);
    }
} else {
    /* Termina o processo-pai sem esperar para sincronizar. */
    exit(0);
}
</code></pre></div></div>

<p>Trabalhar com multi-processos no Unix sempre foi um assunto confuso. A chamada
de sistema <em>fork</em> retorna ao processo-pai o PID do processo-filho. Para o
processo-filho, o retorno do system call é zero. O que não fica explícito no
código é que ao chamar o <em>fork</em>, o seu processo se divide em dois. O que está no
<code class="language-plaintext highlighter-rouge">else</code> do <code class="language-plaintext highlighter-rouge">if (fork() == 0)</code> é o processo-pai. O que está no <code class="language-plaintext highlighter-rouge">then</code> é o
processo-filho.</p>

<p>As chamadas ao system call <code class="language-plaintext highlighter-rouge">exit</code> faz com que o processo seja finalizado
imediatamente. No caso do exemplo, os processos-pai serão finalizados sem
aguardar os processos-filho retornarem. Como dito, em uma situação como esta, o
processo-filho não tem com quem sincronizar para retornar pois os processos-pai
já foram reciclados pelo sistema. Assim, o processo <em>init</em> assume o processo
órfão e este fica dissociado de um terminal, passando a rodar em segundo plano.</p>

<p>De uma forma mais moderna, pode-se usar a função <code class="language-plaintext highlighter-rouge">posix_spawn</code> para carregar
novamente o seu processo em outro espaço de endereçamento. A diferença entre
usar isto e a chamada <code class="language-plaintext highlighter-rouge">fork</code> é que esta última pode gerar problemas com os
frameworks da Apple, em particular se você estiver programando em Swift.</p>

<p>A chamada a <code class="language-plaintext highlighter-rouge">posix_spawn</code> gera um pouco mais de trabalho. Esta função cria um
processo-filho de forma diferente, iniciando o novo processo literalmente do
zero. Você precisa informar a <code class="language-plaintext highlighter-rouge">posix_spawn</code> qual o caminho completo do
executável, ou seja, esta função cria um processo arbitrário totalmente novo que
pode, ou não, ser igual ao processo em execução.</p>

<p>O trabalho extra é que será necessário processar a linha de comando para que seu
programa saiba que está executando como um <em>child process</em>. Este é o método
preferido se você escrever seu código em Swift. O compilador LLVM sequer gera
executável se você tentar usar o <code class="language-plaintext highlighter-rouge">fork</code> justamente porque este system call é
danoso para os frameworks da Apple.</p>

<p>Como o system call <code class="language-plaintext highlighter-rouge">fork</code> é mais simples, achei melhor usá-lo para explicar o
princípio, que continua rigorosamente o mesmo se você usar <code class="language-plaintext highlighter-rouge">posix_spawn</code>.</p>

<h2 id="syslog-e-o-logging-do-seu-daemon">Syslog e o logging do seu daemon</h2>

<p>Existem diversas bibliotecas de logging por aí afora, que trabalham com níveis
de logging e mais uma penca de coisas. Tanto o Linux quanto o Unix oferecem um
sistema completo de logging que normalmente é ignorado pelos desenvolvedores:
<em>syslog</em>.</p>

<p>O <em>syslog</em> tem diversas vantagens que sobrepujam qualquer outro sistema de
logging:</p>

<ul>
  <li>se o seu processo morre inesperadamente, o log é preservado. Se alguma
informação ficou pendente, ela é salva no log pois a comunicação com o
<em>syslog</em> não é bufferizada.</li>
  <li>o logging é feito por um daemon, <em>syslogd</em> normalmente. A comunicação é feita
via pipes ou Unix sockets e é extremamente rápida.</li>
  <li>o <em>syslog</em> faz rotação de log, compactando arquivos antigos e eliminando
arquivos muito antigos.</li>
</ul>

<p>Normalmente o <em>syslog</em> salva as informações de logging no diretório
<code class="language-plaintext highlighter-rouge">/var/log</code>. Este diretório pode variar de acordo com a sua distribuição de Linux
ou sabor de Unix. Algumas distros salvam os logs em <code class="language-plaintext highlighter-rouge">/var/spool/log</code>.</p>

<p>Fazer saídas para <em>stdout</em> ou <em>stderr</em> normalmente não é uma boa ideia. Alguns
sistemas de inicialização fazem o redirecionamento destes streams para arquivos
de log, mas isto não é garantido. Se você gosta de prints da vida, uma dica é:
não faça isso. Use o <em>syslog</em>.</p>

<h2 id="scheduling">Scheduling</h2>

<p>Este é um assunto muito mais voltado à administração do sistema do que
efetivamente ao seu processo. Mas vale a pena passar o olho nisto pois é
possível para um processo alterar a sua própria prioridade.</p>

<p><em>Scheduling</em> tem a ver com a forma como o seu processo será executado dentro do
Linux/Unix. O sistema operacional divide um <em>quantum</em> arbitrário de tempo com
base na prioridade de cada processo, dando a cada processo a oportunidade de
executar. Quanto maior a prioridade de um processo, mais tempo ele terá dentro
da CPU.</p>

<p>Como o Unix é um sistema operacional multi-processo, o <em>scheduling</em> foi a forma
encontrada para compartilhar a CPU com os diversos processos que executam ao
mesmo tempo pois a CPU é uma só. Se há 4 cores, até 4 processos executam
realmente em paralelo. Os demais precisam aguardar para executar.</p>

<p>O <em>scheduling</em> implica na performance da sua aplicação. Quanto maior for a
prioridade, mais rápido é a execução de um processo. A prioridade permite que
seu processo possa, automaticamente, escalar-se para usar mais e mais CPU à
medida em que a demanda aumenta. Assim, o seu processo começa a usar mais CPU e
torna-se mais eficiente.</p>

<h2 id="multi-processos">Multi-processos</h2>

<p>Não é incomum um daemon ser arquitetado para usar diversos processos, cada um
com uma finalidade bem determinada. Um <em>pattern</em> muito comum é o <em>pipeline</em>. A
ideia do pipeline é implementar um workflow usando vários processos. Cada passo
do workflow é realizado por um processo que, ao finalizar, passa para o processo
subsequente a requisição com o resultado do seu processamento.</p>

<p>Este tipo de design é muito usado para permitir o processamento paralelo e exige
alguma forma de comunicação entre os processos. Ao invés de inventar moda, use
alguma forma de IPC: pipes, message queues, semáforos, etc. Tudo isto está
presente e disponível no seu Linux ou Unix há anos, sendo uma maneira muito
eficiente e estável de permitir que vários processos troquem informações entre
si.</p>

<p>Assim, quando vários processos estão na mesma máquina, não há a necessidade de
usar sistemas de mensagens distribuídas, como o MQ Series ou o Rabbit MQ. O
próprio Linux/Unix já lhe dá as message queues prontas para uso.</p>

<h1 id="swift-server-side">Swift Server-side</h1>

<p>A linguagem Swift tem ganhado destaque no desenvolvimento de aplicações do lado
do servidor. Porém, Swift não tem wrappers nativos para integrar chamadas de
sistema com a linguagem. Assim, a forma de realizar isto é importar código C
para o seu software, o que muitas vezes exige a necessidade de escrever wrappers
em C antes de importá-los para o seu código em Swift.</p>

<p>Por exemplo, a função <code class="language-plaintext highlighter-rouge">sigaction</code> tem uma implementação no macOS que exige
que um wrapper C seja criado no intuito de manter o código portável para o
Linux. Assim, cedo ou tarde será necessário escrever algum código em C para que
você integre, adequadamente, o seu servidor Swift no Linux ou Unix.</p>

<h1 id="conclusão">Conclusão</h1>

<p>A correta integração do software server-side com o sistema operacional traz
benefícios inúmeros, tornando seu software mais robusto e usando as
características do sistema operacional como o <em>syslog</em>. A integração com o
sistema de inicialização também é importante para garantir a correta
inicialização/término da sua aplicação.</p>

<p>Como os sistemas Unix foram escritos basicamente em C, cedo ou tarde será
necessário escrever algum código para que seja possível integrar-se o seu
servidor Swift ao sistema operacional.</p>


                <hr>

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/view-code/2017/03/17/com-quantas-views-se-faz-um-APP/" data-toggle="tooltip" data-placement="top" title="Com quantas views se faz uma APP?">&larr; Post Anterior</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/animations/2017/03/19/desmistificando-o-core-animator/" data-toggle="tooltip" data-placement="top" title="Desmistificando o Core Animation">Próximo Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- Disqus Content -->

                <div id="disqus_thread">
                    <script>
                        /**
                        * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
                        * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
                        */

                        /*
                        var disqus_config = function () {
                            this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
                            this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                        };
                        */

                        (function() { // DON'T EDIT BELOW THIS LINE
                        var d = document, s = d.createElement('script');

                        s.src = '//equinocios.disqus.com/embed.js';

                        s.setAttribute('data-timestamp', +new Date());
                        (d.head || d.body).appendChild(s);
                        })();
                    </script>
                    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
                </div>

            </div>
        </div>
    </div>
</article>

<hr>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                </ul>
                <p class="copyright text-muted">A odisseia do puto — Raimundo Pessoa & Frederico Do</p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/clean-blog.min.js "></script>


</body>

</html>
