<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Blog de tecnologia e desenvolvimento — artigos, tutoriais e opinião.">

    <title>Interfaces assíncronas com AsyncDisplayKit - A odisseia do puto</title>

    <link rel="canonical" href="http://localhost:4000/ui/2017/03/29/introducao-ao-asyncdisplaykit-construa-interfaces-asyncronas-no-iOS/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/clean-blog.css">
    <link rel="stylesheet" href="/css/odisseia.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
    
    <!-- Share CSS -->
    <link rel="stylesheet" href="/css/share.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="A odisseia do puto" />

    

</head>


<body>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">A odisseia do puto</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
				
                <li>
                    <a href="/about/">Sobre</a>
                </li>
				
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


    <!-- Post Header -->
<header class="intro-header">
    <div class="intro-header-overlay">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>Interfaces assíncronas com AsyncDisplayKit</h1>
                        
                        <h2 class="subheading">Uma introdução ao AsyncDispkayKit</h2>
                        
                        <span class="meta">Postado por “Guga Oliveira“ em 29/03/2017</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="share">
  <li><a href="https://twitter.com/intent/tweet?text=Interfaces assíncronas com AsyncDisplayKit&url=http://localhost:4000/ui/2017/03/29/introducao-ao-asyncdisplaykit-construa-interfaces-asyncronas-no-iOS/" rel="nofollow" target="_blank" title="Share on Twitter"><i class="fa fa-twitter-square"></i></a></li>
  <li><a href="https://facebook.com/sharer.php?u=http://localhost:4000/ui/2017/03/29/introducao-ao-asyncdisplaykit-construa-interfaces-asyncronas-no-iOS/" rel="nofollow" target="_blank" title="Share on Facebook"><i class="fa fa-facebook-square"></i></a></li>
  <li><a href="http://www.linkedin.com/shareArticle?mini=true&url=http://localhost:4000/ui/2017/03/29/introducao-ao-asyncdisplaykit-construa-interfaces-asyncronas-no-iOS/" rel="nofollow" target="_blank" title="Share on Linkedlin"><i class="fa fa-linkedin-square"></i></a></li>
  <li><a href="https://plus.google.com/share?url=http://localhost:4000/ui/2017/03/29/introducao-ao-asyncdisplaykit-construa-interfaces-asyncronas-no-iOS/" rel="nofollow" target="_blank" title="Share on Google+"><i class="fa fa-google-plus-square"></i></a></li>
</ul>

				<blockquote>
  <p>Sou o Guga Oliveira (<a href="https://twitter.com/gugaoliveira" target="_blank">@gugaoliveira</a>), empreendedor, cursei engenharia eletrônica mas sempre trabalhei com softwares e programação. Abri uma empresa de desenvolvimento Web em Juiz de Fora no início de 2000, e em 2007 fundamos a <a href="http://www.handcom.com.br" target="_blank">Handcom</a> focada em mobilidade. Trabalhamos com iOS desde o início, e criamos aplicativos em sua maioria focados no varejo e com foco empresarial. Em 2014 fundamos a startup <a href="http://www.microlocation.com.br" target="_blank">Microlocation</a> que foi acelerada pelo Seed-MG e hoje faz parte de nossa solução para o varejo <a href="http://www.smartretail.com.br" target="_blank">Smart-Retail</a>, atualmente estou estudando Swift e Análise de Dados, e participando bastante do desenvolvimento dos ecossistemas de Minas Gerais com o MGTI em BH e o Zer040 em Juiz de Fora.</p>
</blockquote>

<h2 id="interface-assíncrona-sem-interface-builder">interface assíncrona? sem Interface Builder?</h2>

<p>Fui apresentado ao <a href="http://asyncdisplaykit.org/">AsyncDisplayKit</a> pelo Heberti Almeida, excelente dev iOS que conheci na WWDC de 2013. Ele estava usando o <code class="language-plaintext highlighter-rouge">ASDK</code> no desenvolvimento do novo app da <a href="https://postbeyond.com" target="_blank">PostBeyond</a>, startup em que ele trabalha. No começo achei complicado apostar em uma biblioteca de terceiros para substituir as bibliotecas próprias do iOS como <code class="language-plaintext highlighter-rouge">UIKit</code>, XIBs e Storyboards.</p>

<p>Mas na WWDC 2016, o Heberti me convidou para ir no evento do <a href="http://www.pinterest.com" target="_blank">Pinterest</a> que acontecia em volta da WWDC. O evento foi promovido pelo Scott Goodsom <a href="https://twitter.com/ScottGoodson" target="_blank">@ScottGoodson</a>, que é Head of Core Experience no Pinterest, e que idealizou a <em>AsyncDisplayKit</em> para desenvolver o <em>Paper</em> para o <em>Facebook</em>.</p>

<p><a href="https://www.youtube.com/watch?v=8ngXakpE2x8" target="_blank"><img src="https://img.youtube.com/vi/8ngXakpE2x8/0.jpg" alt="WWDC 2016 AsyncDisplayKit event " /></a><br />
<em>WWDC 2016 AsyncDisplayKit event</em></p>

<p>O que vi no evento me surpreendeu bastante, engenheiros de apps famosos utilizando intensamente a biblioteca, com foco total em performance visual. O <em>Pinterest</em> utiliza o <em>AsyncDisplayKit</em> e possui engenheiros trabalhando de forma obsessiva na engenharia de renderização das telas para que fiquem extremamente responsivas, com o mínimo <em>drop</em> de <em>frames</em> possível.</p>

<p>Como nosso aplicativo possui uma tela com muitas imagens de produtos e um fluxo quase infinito, como em uma timeline de produtos, resolvemos apostar na re-escrita com o AsyncDisplayKit nas próximas versões, além de quebrar um grande paradigma na empresa, que é o uso de Storyboard e Interface Builder.</p>

<p>Como é um framework complexo, e não por isso difícil de usar, este artigo pretende ser introdutório ao AsyncDisplayKit, tentarei complementar com assuntos mais avançados em breve.</p>

<h2 id="asyncdisplaykit">AsyncDisplayKit</h2>

<p>O <a href="https://github.com/facebook/AsyncDisplayKit" target="_blank">AsyncDisplayKit</a> é uma framework Open Source iOS feito no topo do UIKit com o objetivo de deixar até as interfaces visuais mais complexas com fluxo suave e responsivo. O Framework é <em>Open Source</em> e está disponível via CocoaPods ou Carthage.</p>

<p>O <code class="language-plaintext highlighter-rouge">UIKit</code> é um dos frameworks mais maduros do iOS, e foi desenvolvido quando os iPhones tinham recursos restritos de sistema, no início nem existia possibilidade de utilizar códigos assíncronos concorrentes. O problema é que mesmo atualmente o <code class="language-plaintext highlighter-rouge">UIKit</code> roda em uma única <em>thread</em> e só funciona na <em>main queue</em>. Na maior parte dos casos funciona bem, mas quando envolve interfaces mais complexas ou necessita-se de mais recursos, a interface acaba não sendo tão responsiva. Para estes casos, trabalhar de forma assíncrona é extremamente necessário para criar uma interface lisa e responsiva com o usuário.</p>

<p>O iOS renderiza a interface com o usuário em 60 frames por segundo, o que nos dá apenas 16 milisegundos de CPU por frame, e caso você ultrapasse este mínimo intervalo de tempo o sistema operacional vai começar a liberar drop de frames imediatamente, tornando nossa interface muito menos responsiva e suave, principalmente agora que muitos apps utilizam de animações e efeitos para obter a atenção do usuário.</p>

<p>E nos tempos de autolayout e animações, existem várias tarefas para a <em>main thread</em> realizar e consumir o pequeno tempo de frame que temos, como calcular a dimensão automática de cada célula, resolver os <em>constraints</em> dos conteúdos das views, renderizar e decodificar imagens, criar sombras e contornos, efeitos como blur e shadow, redimensionamento de imagens para exibição e criação e manipulação de objetos do sistema.</p>

<p>O <code class="language-plaintext highlighter-rouge">ASDK</code> (<em>AsyncDisplayKit</em>) chegou para resolver esses problemas, ele move o máximo de trabalho de <code class="language-plaintext highlighter-rouge">UI</code> para ser executado em <em>background</em>. Por default ele permite que todas os cálculos de medidas, estruturações layout e renderizações sejam feitas de forma assíncrona, sem muitas otimizações um app pode experimentar uma grande redução do trabalho realizado na <em>main thread</em>.</p>

<p>O <code class="language-plaintext highlighter-rouge">ASDK</code> é incompatível com <strong><em>Interface Builder</em></strong> e <strong><em>Auto Layout</em></strong>, a biblioteca foi escrita em <em>Objective-C</em>, mas o <code class="language-plaintext highlighter-rouge">ASDK</code> suporta completamente o <em>Swift</em> .</p>

<h3 id="começando">Começando</h3>

<p>A unidade fundamental do <code class="language-plaintext highlighter-rouge">ASDK</code> é o <code class="language-plaintext highlighter-rouge">node</code> ou <code class="language-plaintext highlighter-rouge">ASDisplayNode</code>, ele é uma abstração da <code class="language-plaintext highlighter-rouge">UIView</code>, que por conseguinte é uma abstração da <code class="language-plaintext highlighter-rouge">CALayer</code>. A <code class="language-plaintext highlighter-rouge">UIView</code> só pode ser manipulada na <em>main thread</em>, mas os <code class="language-plaintext highlighter-rouge">nodes</code> são <em>thread safe</em> e podem ser instanciados e ter toda sua hierarquia configurada em <em>background</em> .</p>

<p><img src="/img/gugaoliveira/node-view-layer.png" alt="Node - View - Layer" /></p>

<p>A idéia básica do <code class="language-plaintext highlighter-rouge">ASDK</code> é que você possa trabalhar com os <code class="language-plaintext highlighter-rouge">nodes</code> da mesma forma como já trabalha com as <code class="language-plaintext highlighter-rouge">views</code>, a grande maioria dos métodos e parâmetros da <code class="language-plaintext highlighter-rouge">UIView</code> e da <code class="language-plaintext highlighter-rouge">CALayer</code> possuem equivalentes nos <code class="language-plaintext highlighter-rouge">nodes</code>.</p>

<p>Tudo o que aparece na tela do iOS é renderizado por um objeto <code class="language-plaintext highlighter-rouge">CALayer</code>, a <code class="language-plaintext highlighter-rouge">UIView</code> cria e mantém a referência do objeto <code class="language-plaintext highlighter-rouge">CALayer</code>, e os <code class="language-plaintext highlighter-rouge">nodes</code> extendem a <code class="language-plaintext highlighter-rouge">UIView</code> da mesma forma, como na imagem acima. Você pode acessar a <em>view</em> e o <em>layer</em> que estão abaixo diretamente com <code class="language-plaintext highlighter-rouge">node.view</code> e <code class="language-plaintext highlighter-rouge">node.layer</code>, desde que esteja na <em>main thread</em>.</p>

<h4 id="containers-de-nodes">Containers de nodes</h4>

<p>Os <code class="language-plaintext highlighter-rouge">nodes</code> do <code class="language-plaintext highlighter-rouge">ASDK</code> devem ser usados dentro de <em>containers</em> de <code class="language-plaintext highlighter-rouge">nodes</code>, o <code class="language-plaintext highlighter-rouge">ASDK</code> oferece alguns <em>containers</em>  que tem similares com classes do <code class="language-plaintext highlighter-rouge">UIKit</code> que estamos acostumados a trabalhar. Um <code class="language-plaintext highlighter-rouge">node</code> não deve ser adicionado diretamente a uma hirerarquia de <code class="language-plaintext highlighter-rouge">view</code> (se fizer isso é quase certo de você obter piscadas de tela). Um <code class="language-plaintext highlighter-rouge">node</code> deve ser adicionado como subnode de um <em>container</em> de nodes. Esses <em>containers</em> possuem a tarefa de gerenciar os subnodes para informá-los se está tudo pronto para renderizar na tela de forma mais eficiente possível.</p>

<p>Uma vantagem do uso dos <em>containers</em>  de <code class="language-plaintext highlighter-rouge">nodes</code> é que o <em>container</em> automaticamente gerencia o pre-loading inteligente (<em>Inteligent Preloading</em>) dos <code class="language-plaintext highlighter-rouge">nodes</code> (<code class="language-plaintext highlighter-rouge">views</code>), que significa que toda tarefa de medição do layout, de carregamento de dados, decodificação e renderização serão feitos de forma assíncrona automaticamente.</p>

<p>Os principais containers estão abaixo com os equivalentes no <code class="language-plaintext highlighter-rouge">UIKit</code>:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Container <code class="language-plaintext highlighter-rouge">ASDK</code></th>
      <th style="text-align: center">Equivalente <code class="language-plaintext highlighter-rouge">UIKit</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><a href="http://asyncdisplaykit.org/docs/containers-asviewcontroller.html" target="_blank"><code class="language-plaintext highlighter-rouge">ASViewController</code></a></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">UIViewController</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="http://asyncdisplaykit.org/docs/containers-astablenode.html" target="_blank"><code class="language-plaintext highlighter-rouge">ASTableNode</code></a></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">UITableView</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="http://asyncdisplaykit.org/docs/containers-ascollectionnode.html" target="_blank"><code class="language-plaintext highlighter-rouge">ASCollectionNode</code></a></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">UICollectionView</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><a href="http://asyncdisplaykit.org/docs/containers-aspagernode.html" target="_blank"> <code class="language-plaintext highlighter-rouge">ASPagerNode</code></a></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">UIPageViewController</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">ASNavigationController</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">UINavigationController</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">ASTabBarController </code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">UITabBarController </code></td>
    </tr>
  </tbody>
</table>

<h3 id="layout-engine">Layout Engine</h3>

<p>A <strong><em>Layout Engine</em></strong> do <code class="language-plaintext highlighter-rouge">ASDK</code> é muito poderosa e oferece recursos únicos, ela é baseada no <code class="language-plaintext highlighter-rouge">CSS Box Model</code>, e fornece formas de declarar e especificar o tamanho e posição dos <code class="language-plaintext highlighter-rouge">subnodes</code>. Os <code class="language-plaintext highlighter-rouge">nodes</code> (<code class="language-plaintext highlighter-rouge">views</code>) são renderizados de forma concorrente por default, mas os cálculos de medidas e posição são executados de forma assíncrona ao se usar um <code class="language-plaintext highlighter-rouge">ASLayoutSpec</code> para cada <code class="language-plaintext highlighter-rouge">node</code>. Aqui está a maior diferença entre o <code class="language-plaintext highlighter-rouge">ASDK</code> e o <code class="language-plaintext highlighter-rouge">UIKit</code>, no <code class="language-plaintext highlighter-rouge">ASDK</code> o layout é declarativo e no <code class="language-plaintext highlighter-rouge">UIKit</code> é baseado em <em>constraint</em> com o <code class="language-plaintext highlighter-rouge">Auto Layout</code>.</p>

<p>A <strong><em>Layout Engine</em></strong> será assunto de um segundo artigo que sairá em breve, no entanto no fim do artigo deixarei referências.</p>

<h3 id="instalando">Instalando</h3>

<p>O <code class="language-plaintext highlighter-rouge">ASDK</code> pode ser adicionado ao seu projeto via CocoaPods ou Carthage.</p>

<h4 id="cocoapods">CocoaPods</h4>
<p>Adicione o seguinte comando no seu <code class="language-plaintext highlighter-rouge">Podfile</code>:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>target 'MyApp' do
	pod "AsyncDisplayKit"
end
</code></pre></div></div>

<p>Saia do <code class="language-plaintext highlighter-rouge">XCode</code>, rode o comando dentro do diretório do projeto no Terminal:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; pod install
</code></pre></div></div>

<p>Para atualizar a versão do <code class="language-plaintext highlighter-rouge">ASDK</code>, rode o comando dentro do diretório do projeto no Terminal:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; pod update AsyncDisplayKit
</code></pre></div></div>

<h4 id="carthage">Carthage</h4>
<p>Adicione o seguinte comando no seu <code class="language-plaintext highlighter-rouge">Cartfile</code> para usar a <strong><em>última versão</em></strong> do <code class="language-plaintext highlighter-rouge">ASDK</code>:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>github "facebook/AsyncDisplayKit"
</code></pre></div></div>

<p>Ou para usar a branch <strong><em>master</em></strong>:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>github "facebook/AsyncDisplayKit" "master"
</code></pre></div></div>

<p>No terminal rode:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; carthage update
</code></pre></div></div>

<p>Verifique no terminal se <code class="language-plaintext highlighter-rouge">AsyncDisplayKit</code>, <code class="language-plaintext highlighter-rouge">PINRemoteImage</code> and <code class="language-plaintext highlighter-rouge">PINCache</code> foram carregadas e compiladas.</p>

<h3 id="importando-o-framework">importando o framework</h3>

<p>Importe o header do framework para usá-lo</p>

<pre><code class="language-objective-c">#import &lt;AsyncDisplayKit/AsyncDisplayKit.h&gt;
</code></pre>

<p>Para usar com <code class="language-plaintext highlighter-rouge">swift</code> deve-se criar um <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html" target="_blank"><em>bridge header</em></a>.</p>

<h2 id="mão-na-massa">Mão na massa</h2>

<p>A melhor maneira para iniciar é explorar os projetos de exemplo existentes no <a href="https://github.com/facebook/AsyncDisplayKit" target="_blank">GitHub</a> do <code class="language-plaintext highlighter-rouge">ASDK</code>. A pasta <strong><em>examples</em></strong> possui diversos exemplos, inclusive um simulando o Instagram chamado ASDKgram.</p>

<p>Vamos usar o exemplo ASViewController em Objective-c para nosso exemplo:</p>

<p align="center"><img style="border-radius: 3px;" src="/img/gugaoliveira/ASViewController.png" /></p>

<p>Para criar uma equivalente de <code class="language-plaintext highlighter-rouge">ViewController</code> vamos usar o container <code class="language-plaintext highlighter-rouge">ASViewController</code></p>

<pre><code class="language-objective-c">@interface ViewController : ASViewController
</code></pre>

<p>Nossa <code class="language-plaintext highlighter-rouge">ViewController</code> contem uma <code class="language-plaintext highlighter-rouge">TableView</code> que irá exibir as categorias de Imagens disponíveis para visualização, vamos então implementar a <code class="language-plaintext highlighter-rouge">TableView</code> usando o <code class="language-plaintext highlighter-rouge">ASTableNode</code>.</p>

<p>Declarando o array que contem os nomes da categoria e o <code class="language-plaintext highlighter-rouge">node</code> que reprensenta a <code class="language-plaintext highlighter-rouge">TableView</code>:</p>

<pre><code class="language-objective-c">@property (nonatomic, copy) NSArray *imageCategories;
@property (nonatomic, strong, readonly) ASTableNode *tableNode;
</code></pre>

<p>Vamos configurar a <code class="language-plaintext highlighter-rouge">ViewController</code>, iniciando a <code class="language-plaintext highlighter-rouge">TableNode</code> e o <code class="language-plaintext highlighter-rouge">array</code> usando o <code class="language-plaintext highlighter-rouge">initWithNode</code>:</p>

<pre><code class="language-objective-c">- (instancetype)init
{
    self = [super initWithNode:[ASTableNode new]];
    if (self == nil) { return self; }
    
    _imageCategories = @[@"abstract", @"animals", @"business", @"cats", @"city", @"food", @"nightlife", @"fashion", @"people", @"nature", @"sports", @"technics", @"transport"];
    
    return self;
}
</code></pre>

<p>Assim como na <code class="language-plaintext highlighter-rouge">TableView</code> para usar o <code class="language-plaintext highlighter-rouge">ASTableNode</code> deveremos nos conformar ao <code class="language-plaintext highlighter-rouge">delegate</code> e ao <code class="language-plaintext highlighter-rouge">datasource</code> da <em>TableNode</em></p>

<pre><code class="language-objective-c">....

@interface ViewController () &lt;ASTableDataSource, ASTableDelegate&gt;

.....

- (void)viewDidLoad
{
    [super viewDidLoad];
    
    ...
    
    self.node.delegate = self;
    self.node.dataSource = self;
}

....
- (void)dealloc
{
    self.node.delegate = nil;
    self.node.dataSource = nil;
}
</code></pre>

<p>Agora vamos implementar os <code class="language-plaintext highlighter-rouge">delegates</code> e <code class="language-plaintext highlighter-rouge">datasource</code> da <code class="language-plaintext highlighter-rouge">TableNode</code></p>

<pre><code class="language-Objective-c">- (NSInteger)tableNode:(ASTableNode *)tableNode numberOfRowsInSection:(NSInteger)section
{
    return self.imageCategories.count;
}

- (ASCellNodeBlock)tableNode:(ASTableNode *)tableNode nodeBlockForRowAtIndexPath:(NSIndexPath *)indexPath
{
    // Como o bloco é executado em outra thread em background temos que armazenar a imageCategory fora do bloco 
    NSString *imageCategory = self.imageCategories[indexPath.row];
    return ^{
        ASTextCellNode *textCellNode = [ASTextCellNode new];
        textCellNode.text = [imageCategory capitalizedString];
        return textCellNode;
    };
}

- (void)tableNode:(ASTableNode *)tableNode didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    NSString *imageCategory = self.imageCategories[indexPath.row];
    DetailRootNode *detailRootNode = [[DetailRootNode alloc] initWithImageCategory:imageCategory];
    DetailViewController *detailViewController = [[DetailViewController alloc] initWithNode:detailRootNode];
    detailViewController.title = [imageCategory capitalizedString];
    [self.navigationController pushViewController:detailViewController animated:YES];
}
</code></pre>

<p>Reparem que os métodos são bem similares aos da <code class="language-plaintext highlighter-rouge">UITableView</code>, a <code class="language-plaintext highlighter-rouge">ASTextCellNode</code> é uma subclasse de <code class="language-plaintext highlighter-rouge">ASCellNode</code>, que é o equivalente do <code class="language-plaintext highlighter-rouge">ASDK</code> a <code class="language-plaintext highlighter-rouge">UITableViewCell</code> ou <code class="language-plaintext highlighter-rouge">UICollectionViewCell</code>. No caso a <code class="language-plaintext highlighter-rouge">ASTextCellNode</code> possui um label simples para exibição de texto. Mas existe uma diferença no método de exibição da célula.</p>

<pre><code class="language-Objective-C">
//UITableView
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath

//ASTableNode
- (ASCellNodeBlock)tableNode:(ASTableNode *)tableNode nodeBlockForRowAtIndexPath:(NSIndexPath *)indexPath
</code></pre>

<p>A diferença aqui é que o retorno é um bloco de código que pode ser executado em background pelo <code class="language-plaintext highlighter-rouge">ASDK</code>, neste caso a variável <code class="language-plaintext highlighter-rouge">indexPath</code> não pode ser usada dentro do bloco, pois os dados podem mudar antes do bloco ser executado. Não é necessário reusar as celulas, o <code class="language-plaintext highlighter-rouge">ASDK</code> faz o trabalho para você, basta iniciar o <code class="language-plaintext highlighter-rouge">ASCellNode</code> e retorná-lo ao fim do bloco.</p>

<p>Ao se selecionar uma linha da <code class="language-plaintext highlighter-rouge">TableNode</code> instanciamos a classe <strong><em>DetailRootNode</em></strong>, que é uma subclasse de <code class="language-plaintext highlighter-rouge">ASDisplayNode</code> (o node fundamental do <code class="language-plaintext highlighter-rouge">ASDK</code>), com o inicializador que recebe o nome da categoria de imagens, depois instanciamos a <strong><em>DetailViewController</em></strong> que é uma subclasse de <code class="language-plaintext highlighter-rouge">ASViewController</code> com o <code class="language-plaintext highlighter-rouge">node</code> <strong><em>DetailRootControler</em></strong></p>

<p>Na <strong><em>DetailRootNode</em></strong> temos uma instância de <code class="language-plaintext highlighter-rouge">ASCollectionNode</code> o <em>container</em> de <code class="language-plaintext highlighter-rouge">nodes</code> que é equivalente a <code class="language-plaintext highlighter-rouge">UIViewController</code>. Aqui vamos usar a capacidade de um <code class="language-plaintext highlighter-rouge">node</code> gerenciar os <code class="language-plaintext highlighter-rouge">subnodes</code>, automaticamente o <code class="language-plaintext highlighter-rouge">ASDK</code> irá adicionar a <code class="language-plaintext highlighter-rouge">CollectionView</code> à view <strong><em>DetailRootNode</em></strong> que é adicionada à DetailViewController.</p>

<pre><code class="language-Objective-C">// DetailRootNode é um ASDisplayNode
@interface DetailRootNode : ASDisplayNode

//o ASDisplayNode possui uma ASCollectionNode (equivalente UIViewCollection)
@property (nonatomic, strong, readonly) ASCollectionNode *collectionNode;

....

// conforma-se os delegates e datasource da ASCollectionView

@interface DetailRootNode () &lt;ASCollectionDataSource, ASCollectionDelegate&gt;

....

- (instancetype)initWithImageCategory:(NSString *)imageCategory
{
    self = [super init];
    if (self) {
        // Habilita o gerenciamento automatico dos subnodes todos os nodes que 
        // estiverem referenciados no metodo layoutSpecThatFits: serão adicionados automaticamente
        self.automaticallyManagesSubnodes = YES;
        
        _imageCategory = imageCategory;

        // Cria a ASCollectionView. Não é necessário adicionar como subnode explicitamente por que iremos configurar o parametro usesImplicitHierarchyManagement para YES
        UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc] init];
        _collectionNode = [[ASCollectionNode alloc] initWithCollectionViewLayout:layout];
        _collectionNode.delegate = self;
        _collectionNode.dataSource = self;
        _collectionNode.backgroundColor = [UIColor whiteColor];
    }
    
    return self;
}

... 

// adiciona e calcula automaticamente as dimensoes do DisplayNode com a CollectionView
- (ASLayoutSpec *)layoutSpecThatFits:(ASSizeRange)constrainedSize
{
    return [ASWrapperLayoutSpec wrapperWithLayoutElement:self.collectionNode];
}

...

#pragma mark - ASCollectionDataSource

- (NSInteger)collectionNode:(ASCollectionNode *)collectionNode numberOfItemsInSection:(NSInteger)section
{
    return 10;
}

- (ASCellNodeBlock)collectionNode:(ASCollectionNode *)collectionNode nodeBlockForItemAtIndexPath:(NSIndexPath *)indexPath
{
    NSString *imageCategory = self.imageCategory;
    return ^{
        DetailCellNode *node = [[DetailCellNode alloc] init];
        node.row = indexPath.row;
        node.imageCategory = imageCategory;
        return node;
    };
}

- (ASSizeRange)collectionNode:(ASCollectionNode *)collectionNode constrainedSizeForItemAtIndexPath:(NSIndexPath *)indexPath
{
    CGSize imageSize = CGSizeMake(CGRectGetWidth(collectionNode.view.frame), kImageHeight);
    return ASSizeRangeMake(imageSize, imageSize);
}

</code></pre>

<p>Como podem perceber a <code class="language-plaintext highlighter-rouge">ViewController</code> <strong><em>DetailViewController</em></strong> é criada com uma view que contem uma <code class="language-plaintext highlighter-rouge">CollectionView</code>, esta carrega 10 imagens de uma api em cada célula. A <strong><em>DetailCellNode</em></strong> é uma CollectionViewCell que é configurada em um bloco carregado em background pelo <code class="language-plaintext highlighter-rouge">ASDK</code> após as imagens serem carregadas. A <code class="language-plaintext highlighter-rouge">UI</code> em nenhum momento deixa de ser responsível ou fluida.</p>

<h2 id="terminando">Terminando</h2>

<p>Este é um exemplo simples que demonstra como é intuitivo e fácil trabalhar com o <code class="language-plaintext highlighter-rouge">ASDK</code>, existem muitos tópicos avançados de como melhorar ainda mais a performance. Neste artigo não pudemos falar sobre Layout, Inteligent Preloading e outras conveniências. Ele serve como um start para a avaliação da biblioteca como substituta do UIKit para criar interfaces mais fluidas e responsivas.</p>

<p>Agradeço a leitura e fico aberto a sugestões e críticas, este foi o meu primeiro artigo de desenvolvimento, e pretendo escrever mais.</p>

<p>Seguem meus contatos:</p>

<ul>
  <li><a href="https://twitter.com/gugaoliveira" target="_blank">Twitter (@gugaoliveira)</a></li>
  <li>Slack do <a href="http://iosdevbr.herokuapp.com/" target="_blank">iOSDevBR</a> (@gugaoliveira).</li>
</ul>

<p>Agradecimentos especiais ao <a href="https://twitter.com/hebertialmeida" target="_blank">Heberti Almeida</a>, que já utiliza o <code class="language-plaintext highlighter-rouge">ASDK</code> há bastante tempo e me apresentou esta biblioteca fantástica e também seus criadores, foi realmente bacana poder conversar com os criadores e ter uma canal de comunicação direta.</p>

<hr />

<h2 id="referências">Referências</h2>

<ul>
  <li><a href="http://asyncdisplaykit.org/docs/getting-started.html" target="_blank">AsyncDisplayKit Getting Starded</a></li>
  <li><a href="http://www.appcoda.com/introduction-asyncdisplaykit-2-0/" target="_blank">Using AsyncDisplayKit to Develop Responsive UIs in iOS</a> <strong><em>[Ziad Tamim, 29/12/2016]</em></strong></li>
  <li><a href="https://www.raywenderlich.com/124311/asyncdisplaykit-2-0-tutorial-getting-started" target="_blank">AsyncDisplayKit 2.0 Tutorial: Getting Started</a> <strong><em>[Luke Parham, 5/12/2016]</em></strong></li>
  <li><a href="http://asyncdisplaykit.org/slack.html" target="_blank">Slack do AsyncDisplayKit</a></li>
</ul>

<h3 id="referências-de-layout">Referências de Layout</h3>
<ul>
  <li><a href="https://www.raywenderlich.com/124696/asyncdisplaykit-2-0-tutorial-automatic-layout" target="_blank">AsyncDisplayKit 2.0 Tutorial: Automatic Layout</a> <strong><em>[Luke Parham, 19/12/2016]</em></strong></li>
  <li><a href="https://www.youtube.com/watch?v=sqkinHYXTuc" target="_blank">Layout at Scale with AsyncDisplayKit 2.0</a> <strong><em>[NSMeetup 2016]</em></strong></li>
  <li><a href="http://huytnguyen.me/froggy-asdk-layout/" target="_blank">ASStackLayout Game</a></li>
</ul>


                <hr>

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/continuidade/2017/03/27/adotando-handoff/" data-toggle="tooltip" data-placement="top" title="Adotando Handoff em iOS e macOS">&larr; Post Anterior</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/banco%20de%20dados/2017/03/30/persistencia-de-dados-usando-core-data/" data-toggle="tooltip" data-placement="top" title="Persistência de dados usando Core Data">Próximo Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- Disqus Content -->

                <div id="disqus_thread">
                    <script>
                        /**
                        * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
                        * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
                        */

                        /*
                        var disqus_config = function () {
                            this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
                            this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                        };
                        */

                        (function() { // DON'T EDIT BELOW THIS LINE
                        var d = document, s = d.createElement('script');

                        s.src = '//equinocios.disqus.com/embed.js';

                        s.setAttribute('data-timestamp', +new Date());
                        (d.head || d.body).appendChild(s);
                        })();
                    </script>
                    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
                </div>

            </div>
        </div>
    </div>
</article>

<hr>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                </ul>
                <p class="copyright text-muted">A odisseia do puto — Raimundo Pessoa & Frederico Do</p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/clean-blog.min.js "></script>


</body>

</html>
