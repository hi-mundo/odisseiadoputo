<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Blog de tecnologia e desenvolvimento ‚Äî artigos, tutoriais e opini√£o.">

    <title>Optionals e o Gato de Schr√∂dinger - A odisseia do puto</title>

    <link rel="canonical" href="http://localhost:4000/optionals/2016/03/24/optionals-e-o-gato-de-schrodinger/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/clean-blog.css">
    <link rel="stylesheet" href="/css/odisseia.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
    
    <!-- Share CSS -->
    <link rel="stylesheet" href="/css/share.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="A odisseia do puto" />

    

</head>


<body>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">A odisseia do puto</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
				
                <li>
                    <a href="/about/">Sobre</a>
                </li>
				
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


    <!-- Post Header -->
<header class="intro-header">
    <div class="intro-header-overlay">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>Optionals e o Gato de Schr√∂dinger</h1>
                        
                        <h2 class="subheading">Optionals? Optionals!</h2>
                        
                        <span class="meta">Postado por Francesco Perrotti-Garcia em 24/03/2016</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="share">
  <li><a href="https://twitter.com/intent/tweet?text=Optionals e o Gato de Schr√∂dinger&url=http://localhost:4000/optionals/2016/03/24/optionals-e-o-gato-de-schrodinger/" rel="nofollow" target="_blank" title="Share on Twitter"><i class="fa fa-twitter-square"></i></a></li>
  <li><a href="https://facebook.com/sharer.php?u=http://localhost:4000/optionals/2016/03/24/optionals-e-o-gato-de-schrodinger/" rel="nofollow" target="_blank" title="Share on Facebook"><i class="fa fa-facebook-square"></i></a></li>
  <li><a href="http://www.linkedin.com/shareArticle?mini=true&url=http://localhost:4000/optionals/2016/03/24/optionals-e-o-gato-de-schrodinger/" rel="nofollow" target="_blank" title="Share on Linkedlin"><i class="fa fa-linkedin-square"></i></a></li>
  <li><a href="https://plus.google.com/share?url=http://localhost:4000/optionals/2016/03/24/optionals-e-o-gato-de-schrodinger/" rel="nofollow" target="_blank" title="Share on Google+"><i class="fa fa-google-plus-square"></i></a></li>
</ul>

				<blockquote>
  <p>Francesco Perrotti-Garcia (<a href="https://twitter.com/fpg1503" target="_blank">@fpg1503</a>) √© desenvolvedor iOS. Atualmente trabalha no <a href="https://playkidsapp.com" target="_blank">PlayKids</a>) fazendo a melhor fam√≠lia de aplicativos para crian√ßas do mundo. Programa desde os 12 anos e nos √∫ltimos 5 est√° cada vez mas envolvido com desenvolvimento iOS. Swift mudou sua maneira de ver o mundo e at√© de como programar em Objective-C. Adora gatos e nas horas vagas gosta de viajar, cozinhar e tirar fotos.</p>
</blockquote>

<h1 id="o-que-s√£o-optionals">O que s√£o Optionals?</h1>

<p>O <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309">Swift Programming Guide</a> define <code class="language-plaintext highlighter-rouge">Optional</code> como:</p>

<blockquote>
  <p>[‚Ä¶] tipos opcionais lidam com a aus√™ncia de um valor. Eles dizem ‚Äúh√° um valor e ele 
√© x‚Äù ou ‚Äún√£o h√° valor algum‚Äù. Us√°-los √© semelhante a usar nil com ponteiros em Objective-C mas eles funcionam para todos os tipos, n√£o s√≥ para classes. Eles n√£o s√≥ s√£o mais seguros e expressivos do que ponteiros nulos, como est√£o no cora√ß√£o de muitas das funcionalidades mais poderosas de Swift.</p>
</blockquote>

<p>Desenvolvedores de Objective-C nunca se preocuparam muito com nulabilidade, enviar uma mensagem para <code class="language-plaintext highlighter-rouge">nil</code> simplesmente retornava <code class="language-plaintext highlighter-rouge">nil</code> e isso era lindo (ou pelo menos pens√°vamos assim). Toda conversa de bar com nossos colegas desenvolvedores Java eram um bom motivo para trazer <em>null pointer exceptions</em> √† tona. Foi com essa mentalidade que eu e muitas colegas come√ßamos a desenvolver em Swift, mas este n√£o √© um bom caminho. Depois de muita reflex√£o e discuss√£o considero que a raiz de todo mal esteja em tentar fazer encarar <code class="language-plaintext highlighter-rouge">Optional</code>s da mesma forma que encar√°vamos <code class="language-plaintext highlighter-rouge">nil</code>. Uma maneira que gosto de abordar esse tema √© usando a met√°fora do <em>Gato de Schr√∂dinger</em>.</p>

<h1 id="gato-de-schr√∂dinger"><em>Gato de Schr√∂dinger</em></h1>

<h2 id="o-que-√©">O que √©?</h2>

<p>Uma experi√™ncia mental na qual um gato √© imaginado em uma caixa com uma fonte de radia√ß√£o e um veneno que ser√° liberado assim que essa fonte (imprevisivelmente) emitir radia√ß√£o. O gato √© (de acordo com a mec√¢nica qu√¢ntica) considerado ao mesmo simultaneamente vivo e morto at√© que a caixa seja aberta e o gato observado.</p>

<h2 id="modelando">Modelando</h2>

<p>Deixando <code class="language-plaintext highlighter-rouge">Optional</code>s de lado por um tempo vamos supor agora que quis√©ssemos modelar esse problema: de maneira bem simplista podemos dizer que h√° dois estados poss√≠veis para o gato: <strong>vivo</strong> e <strong>morto</strong>. Uma maneira interessante de fazer isso seria utilizando um <code class="language-plaintext highlighter-rouge">enum</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">Cat</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kt">Alive</span>
    <span class="k">case</span> <span class="kt">Dead</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/img/fpg1503/alivedead.png" alt="" /></p>

<p>Se houvesse uma inst√¢ncia de <code class="language-plaintext highlighter-rouge">Cat</code> chamada <code class="language-plaintext highlighter-rouge">meow</code> a √∫nica maneira de sabermos se ele est√° vivo ou morto √© checando (o que √© an√°logo a abrir a caixa no experimento).</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="n">meow</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="kt">Alive</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"The cat is alive!"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">.</span><span class="kt">Dead</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"The cat is dead :("</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="fazendo-o-nosso-optional">Fazendo o nosso <code class="language-plaintext highlighter-rouge">Optional</code></h1>

<h2 id="abordagem-inicial">Abordagem Inicial</h2>

<p>Voltando para Optionals podemos dizer que, como o gato, √© poss√≠vel model√°-los com dois estados: <strong>alguma coisa</strong> ou <strong>nada</strong>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">MyOptional</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kt">Some</span>
    <span class="k">case</span> <span class="kt">None</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">nothing</span> <span class="o">=</span> <span class="kt">MyOptional</span><span class="o">.</span><span class="kt">None</span>
<span class="k">let</span> <span class="nv">something</span> <span class="o">=</span> <span class="kt">MyOptional</span><span class="o">.</span><span class="kt">Some</span>
</code></pre></div></div>

<h2 id="enumera√ß√µes-com-valor-associado">Enumera√ß√µes com valor associado</h2>

<p>Uma das funcionalidades mais legais de Swift na minha opni√£o √© poder criar <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145">enums com valor associado</a> e com isso √© poss√≠vel fazer um modelo mais realista (e us√°vel!) de um <code class="language-plaintext highlighter-rouge">Optional</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">MyOptional</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kt">Some</span><span class="p">(</span><span class="kt">Any</span><span class="p">)</span>
    <span class="k">case</span> <span class="kt">None</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">something</span> <span class="o">=</span> <span class="kt">MyOptional</span><span class="o">.</span><span class="kt">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>

<p>O problema dessa abordagem √© que perdemos toda a <strong>magia</strong> dos tipos: se checamos <code class="language-plaintext highlighter-rouge">something.dynamicType</code> a resposta obtida √© <code class="language-plaintext highlighter-rouge">MyOptional.Type</code>. Isso n√£o nos diz muito coisa.</p>

<h1 id="gen√©ricos">Gen√©ricos</h1>

<p>Outra funcionalidade excepcional de Swift s√£o os <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179">gen√©ricos</a>: de forma (incrivelmente) resumida, gen√©ricos permitem que voc√™ trabalhe com uma estrutura de forma gen√©rica (faz sentido, n√£o?) e reus√°vel que funcionem em cima de qualquer tipo!</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">MyOptional</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kt">Some</span><span class="p">(</span><span class="kt">T</span><span class="p">)</span>
    <span class="k">case</span> <span class="kt">None</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">something</span> <span class="o">=</span> <span class="kt">MyOptional</span><span class="o">.</span><span class="kt">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>

<p>Agora ao checar <code class="language-plaintext highlighter-rouge">something.dynamicType</code> a resposta obtida √© <code class="language-plaintext highlighter-rouge">MyOptional&lt;Int&gt;.Type</code>! Bem mais interessante, n√£o?</p>

<p>Se tentarmos criar uma inst√¢ncia de nada agora usando <code class="language-plaintext highlighter-rouge">let nothing = MyOptional.None</code> obtemos o seguinte erro:</p>

<blockquote>
  <p><strong>Generic parameter ‚Äò</strong><code class="language-plaintext highlighter-rouge">T</code><strong>‚Äô could not be inferred</strong></p>
</blockquote>

<p>E isso <strong>faz muito sentido</strong>: na nossa abstra√ß√£o queremos expressar a aus√™ncia de um valor, mas de um valor de que tipo? Se esse tipo fosse <code class="language-plaintext highlighter-rouge">Int</code>, por exemplo, poderiamos fazer <code class="language-plaintext highlighter-rouge">let nothing = MyOptional&lt;Int&gt;.None</code>.</p>

<h2 id="inicializadores-de-optional">Inicializadores de <code class="language-plaintext highlighter-rouge">Optional</code></h2>

<h3 id="nada">Nada</h3>
<p>Criar um <code class="language-plaintext highlighter-rouge">Optional</code> √© t√£o simples quanto <code class="language-plaintext highlighter-rouge">Optional&lt;Int&gt;()</code> ou <code class="language-plaintext highlighter-rouge">Optional&lt;MyNeatType&gt;()</code>, por√©m se tentarmos fazer algo como <code class="language-plaintext highlighter-rouge">MyOptional&lt;MyNeatType&gt;()</code> obtemos um erro:</p>

<blockquote>
  <p><em>error:</em> ‚Äò<code class="language-plaintext highlighter-rouge">MyOptional&lt;MyNeatType&gt;</code>‚Äô cannot be constructed because it has no accessible initializers</p>
</blockquote>

<p>Podemos resolver isso facilmente criando um inicializador!</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">self</span> <span class="o">=</span> <span class="o">.</span><span class="kt">None</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="alguma-coisa">Alguma coisa</h3>

<p>Analogamente obter√≠amos um erro se tentassemos fazer:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">foo</span> <span class="o">=</span> <span class="kt">MyNeatType</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">bar</span> <span class="o">=</span> <span class="kt">MyOptional</span><span class="o">&lt;</span><span class="kt">MyNeatType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p><em>error:</em> argument passed to call that takes no arguments</p>
</blockquote>

<p>Escrever um incializador para esse caso √© simples e usa nosso tipo gen√©rico <code class="language-plaintext highlighter-rouge">T</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">some</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span> <span class="o">=</span> <span class="o">.</span><span class="kt">Some</span><span class="p">(</span><span class="kd">some</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="optionals-como-caixas">Optionals como caixas</h1>

<p><img src="/img/fpg1503/box.png" alt="" /></p>

<p>Definindo desse jeito, <code class="language-plaintext highlighter-rouge">Optional</code>s se mostram como excelentes caixas: pode haver um valor dentro, mas s√≥ saberemos ao abrir a caixa (ou desembrulhar o valor). Uma das excelentes belezas disso √© que <code class="language-plaintext highlighter-rouge">MyOptional&lt;Int&gt;</code> √© <strong>intrinsecamente diferente</strong> de <code class="language-plaintext highlighter-rouge">Int</code> e, enquanto somar dois <code class="language-plaintext highlighter-rouge">Int</code>s faz sentido, tentar somar dois Optionals mostrar√° que s√≥ devemos efetuar essa opera√ß√£o se ambos existirem. Mas primeiro <strong>√© necess√°rio checar</strong>.</p>

<p>Esse tipo de questionamento √© exatamente o que n√£o faz√≠amos em Objective-C (e se faz√≠amos, n√£o t√≠nhamos como expressar). Como saber se um m√©todo de Objective-C pode retornar ou receber <code class="language-plaintext highlighter-rouge">nil</code>? Olhe a documenta√ß√£o, se voc√™ tiver sorte estar√° l√°. Isso mudou um pouco com as <a href="https://developer.apple.com/swift/blog/?id=25">anota√ß√µes de nulabilidade</a> mas ainda n√£o √© parte de nosso mindset.</p>

<h2 id="desembrulhando">Desembrulhando</h2>

<p>Desembrulhar nossos Optionals √© bem simples! Eles s√£o enumera√ß√µes e trabalhar com enumera√ß√µes em Swift √© <strong>incrivelmente prazeroso</strong>:</p>

<h3 id="switch">switch</h3>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">optionalNumber</span> <span class="o">=</span> <span class="kt">MyOptional</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="k">switch</span> <span class="n">optionalNumber</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="kt">None</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"No number ¬Ø</span><span class="se">\\</span><span class="s">_(„ÉÑ)_/¬Ø"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">.</span><span class="kt">Some</span><span class="p">(</span><span class="k">let</span> <span class="nv">number</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">number</span><span class="se">)</span><span class="s">, Numberwang!"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pattern-matching">Pattern Matching</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">optionalNumber</span> <span class="o">=</span> <span class="kt">MyOptional</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="k">if</span> <span class="k">case</span> <span class="o">.</span><span class="kt">Some</span><span class="p">(</span><span class="k">let</span> <span class="nv">number</span><span class="p">)</span> <span class="o">=</span> <span class="n">optionalNumber</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">number</span><span class="se">)</span><span class="s">, Numberwang!"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Essa sintaxe √© muito parecida com nosso t√£o amado <code class="language-plaintext highlighter-rouge">if let</code>, n√£o √© mesmo? Isso acontece pois <strong>Optionals s√£o enums!</strong> Sim, sua vida √© uma mentira! Optionals n√£o passam de um enum e a√ß√∫car sint√°tico!</p>

<h1 id="a√ß√∫car-sint√°tico-e-optionals">A√ß√∫car sint√°tico e Optionals</h1>

<p>Como dissemos l√° em cima, Optionals est√£o incrivelmente enraizados em Swift e isso √© poss√≠vel gra√ßas a <strong>muito</strong> a√ß√∫car sint√°tico (quase um canavial sint√°tico üòù). Vamos ver agora o que conseguimos reproduzir e o que √© a√ßucar sint√°tico:</p>

<h2 id="if-let"><code class="language-plaintext highlighter-rouge">if let</code></h2>
<p>O <code class="language-plaintext highlighter-rouge">if let</code> funciona se houver um caso <code class="language-plaintext highlighter-rouge">.Some</code> com um valor associado! Sim! Podemos usar <code class="language-plaintext highlighter-rouge">if let</code> com <code class="language-plaintext highlighter-rouge">MyOptional</code>, n√£o √© lindo? üòÅ</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">optionalNumber</span> <span class="o">=</span> <span class="kt">MyOptional</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">8001</span><span class="p">)</span>
<span class="k">if</span> <span class="k">let</span> <span class="nv">number</span> <span class="o">=</span> <span class="n">optionalNumber</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">number</span><span class="se">)</span><span class="s">, Numberwang!"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="var-optionalnumber-myoptionalint--nil"><code class="language-plaintext highlighter-rouge">var optionalNumber: MyOptional&lt;Int&gt; = nil</code></h2>

<p>Consigo criar Optionals que representam a aus√™ncia de um valor usando <code class="language-plaintext highlighter-rouge">nil</code>. Isso √© facilmente implementado! Swift tem <code class="language-plaintext highlighter-rouge">LiteralConvertibles</code> que, de forma bem resumida, s√£o coisas que podem ser criadas a partir de um <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/zzSummaryOfTheGrammar.html#//apple_ref/doc/uid/TP40014097-CH38-ID458">literal</a>.</p>

<p>H√° um artigo fenomenal do <a href="https://twitter.com/mattt" target="_blank">@mattt</a> no <a href="http://nshipster.com/swift-literal-convertible/">NSHipster sobre Swift Literal Convertibles</a> ent√£o n√£o entrarei em muitos detalhes aqui. Como brinde se voc√™ sempre se perguntou <strong>o que ocorre quando uso um literal</strong> recomendo fortemente dar uma olhada nos <a href="https://github.com/apple/swift/blob/master/docs/Literals.rst">docs do Swift</a>.</p>

<h3 id="nilliteralconvertible"><code class="language-plaintext highlighter-rouge">NilLiteralConvertible</code></h3>
<p>Como o pr√≥prio nome sugere <code class="language-plaintext highlighter-rouge">NilLiteralConvertible</code>s s√£o coisas que podem ser criadas a partir de um <code class="language-plaintext highlighter-rouge">nil</code>. √â um protocolo que define uma √∫nica fun√ß√£o:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">NilLiteralConvertible</span> <span class="p">{</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">nilLiteral</span><span class="p">:</span> <span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Nativamente este protocolo √© implementado por <code class="language-plaintext highlighter-rouge">Optional</code> e <code class="language-plaintext highlighter-rouge">ImplicltlyUnwrappedOptional</code>. A t√≠tulo de curiosidade, ele tamb√©m √© usado por <code class="language-plaintext highlighter-rouge">UnsafePointer</code>, <code class="language-plaintext highlighter-rouge">UnsafeMutablePointer</code>, <code class="language-plaintext highlighter-rouge">AutoReleasingUnsafeMutablePointer</code> e <code class="language-plaintext highlighter-rouge">COpaquePointer</code> mas eles fogem do escopo deste artigo.</p>

<p>Como vimos, basta criar uma extens√£o para nosso <code class="language-plaintext highlighter-rouge">enum</code> que lida o caso. Notem que <strong>a aus√™ncia √© representada pela tupla vazia</strong>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">MyOptional</span><span class="p">:</span> <span class="kt">NilLiteralConvertible</span> <span class="p">{</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">nilLiteral</span><span class="p">:</span> <span class="p">())</span> <span class="p">{</span>
        <span class="k">self</span> <span class="o">=</span> <span class="o">.</span><span class="kt">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="o-que-n√£o-conseguimos-recriar">O que n√£o conseguimos recriar</h2>

<h3 id="ponto-de-interroga√ß√£o">Ponto de Interroga√ß√£o</h3>

<p>O ponto de interroga√ß√£o como sufixo de um tipo √© puro a√ß√∫car sint√°tico e por isso n√£o √© poss√≠vel us√°-lo para nosso Optional üòï</p>

<h3 id="inicializadores-fal√≠veis">Inicializadores Fal√≠veis</h3>

<p>Agora que entendemos melhor o que s√£o Optionals, vemos que inicializadores fal√≠veis n√£o fazem muito sentido! Se a √∫nica maneira de eu representar a aus√™ncia de um valor √© com <code class="language-plaintext highlighter-rouge">Optional</code> ent√£o inicializadores fal√≠veis seriam imposs√≠veis.</p>

<p>Considere que um inicializador sempre retorna o tipo dele: como retornar√≠amos outro tipo!? Tomemos como exemplo um dos mais famosos inicializadores fal√≠veis: o de <code class="language-plaintext highlighter-rouge">NSURL</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">NSURL</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">convenience</span> <span class="nf">init</span><span class="p">?(</span><span class="n">string</span> <span class="kt">URLString</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>O c√≥digo abaixo imprime <code class="language-plaintext highlighter-rouge">Optional&lt;NSURL&gt;</code></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">url</span> <span class="o">=</span> <span class="kt">NSURL</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="s">""</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">url</span><span class="o">.</span><span class="k">dynamicType</span><span class="p">)</span>
</code></pre></div></div>

<p>Ou seja: inicializadores fal√≠veis <strong>n√£o s√£o inicializadores do seu tipo!</strong> üò±. Eles s√£o puro a√ß√∫car sint√°tico: uma coisa que deixa isso bem evidente √© o erro obtido ao tentar fazer algo como:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{}</span>

<span class="nf">init</span><span class="p">?(</span><span class="nv">password</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="n">name</span> <span class="o">==</span> <span class="s">"tijolo22"</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">.</span><span class="kt">None</span>
    <span class="p">}</span>
    <span class="k">self</span> <span class="o">=</span> <span class="kt">SecretObject</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">nil</code> is the only return value permitted in an initializer</p>
</blockquote>

<p>O que mostra que o valor de retorno n√£o est√° de fato sendo usado! Simplesmente √© checado se ele √© <code class="language-plaintext highlighter-rouge">nil</code>. Trocar <code class="language-plaintext highlighter-rouge">.None</code> para <code class="language-plaintext highlighter-rouge">nil</code> faz o c√≥digo funcionar:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{}</span>

<span class="nf">init</span><span class="p">?(</span><span class="nv">password</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="n">name</span> <span class="o">==</span> <span class="s">"tijolo22"</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="k">self</span> <span class="o">=</span> <span class="kt">SecretObject</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="optionals-s√£o-m√¥nadas-cont√™ineres">Optionals s√£o <s>m√¥nadas</s> cont√™ineres</h1>

<p>Sim, Optionals s√£o m√¥nadas e h√° uma excelente talk sobre m√¥nadas chamada <a href="https://www.youtube.com/watch?v=vg7cOF30Svo">Monads are not Monsters</a> da UIKont de 2015 (obrigado <a href="https://twitter.com/talesp" target="_blank">@talesp</a> pela recomenda√ß√£o!) mas para simplificar vamos s√≥ dizer que Optionals s√£o cont√™ineres.</p>

<p>Em cont√™ineres podemos implementar <code class="language-plaintext highlighter-rouge">map</code> e <code class="language-plaintext highlighter-rouge">flatMap</code>, de maneira resumida:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">map(f)</code> aplica uma fun√ß√£o <code class="language-plaintext highlighter-rouge">f</code> a cada valor contido no cont√™iner e insere os resultados em um novo cont√™iner.</li>
  <li><code class="language-plaintext highlighter-rouge">flatMap</code> faz a mesma coisa por√©m ao final ‚Äúachata‚Äù o cont√™inter, ou seja, cria um cont√™iner com o conte√∫do de seus sub-cont√™ineres.</li>
</ul>

<p>Pensando em listas, achatar <code class="language-plaintext highlighter-rouge">[[1, 2], 3, [4, [5]]]</code> produz <code class="language-plaintext highlighter-rouge">[1, 2, 3, 4, [5]]</code> (notem que apenas uma camada √© achatada).</p>

<h2 id="mas-algu√©m-usa-isso">Mas algu√©m usa isso?</h2>
<p>Sim! Antigamente achava que nem, mas cada vez mais vejo colegas usando <code class="language-plaintext highlighter-rouge">map</code> e <code class="language-plaintext highlighter-rouge">flatMap</code> para reduzir mutabilidade dentro de fun√ß√µes e criar c√≥digos mais expressivos. √â estranho no come√ßo, mas depois de pouqu√≠ssimo tempo voc√™ vai falar: <em>como eu vivi at√© hoje sem isso?</em>.</p>

<h2 id="map"><code class="language-plaintext highlighter-rouge">map</code></h2>

<p>Implementar <code class="language-plaintext highlighter-rouge">map</code> √© simples: se h√° um valor, retornamos o valor da aplica√ß√£o de <code class="language-plaintext highlighter-rouge">f</code> nele. Sen√£o, retornamos <code class="language-plaintext highlighter-rouge">.None</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="n">map</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">f</span><span class="p">:</span> <span class="p">(</span><span class="kt">T</span> <span class="o">-&gt;</span> <span class="kt">U</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="kt">MyOptional</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="k">self</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">.</span><span class="kt">None</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="nv">mappedValue</span> <span class="o">=</span> <span class="nf">f</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">.</span><span class="kt">Some</span><span class="p">(</span><span class="n">mappedValue</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Por√©m, h√° um problema: isso n√£o funcionaria se <code class="language-plaintext highlighter-rouge">f throws</code>. Isso √© facilmente resolvido usando <code class="language-plaintext highlighter-rouge">rethrows</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="n">map</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">f</span><span class="p">:</span> <span class="p">(</span><span class="kt">T</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">U</span><span class="p">))</span> <span class="k">rethrows</span> <span class="o">-&gt;</span> <span class="kt">MyOptional</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="k">self</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">.</span><span class="kt">None</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="nv">mappedValue</span> <span class="o">=</span> <span class="k">try</span> <span class="nf">f</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">.</span><span class="kt">Some</span><span class="p">(</span><span class="n">mappedValue</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Por ser de um idioma funcional n√£o queremos que nosso <code class="language-plaintext highlighter-rouge">map</code> seja usado por seu efeito colateral, ou seja, n√£o queremos que seu resultado seja ignorado. Para garantir isso basta incluir <code class="language-plaintext highlighter-rouge">@warn_unused_result</code> antes da declara√ß√£o da fun√ß√£o e deixar o compilador fazer sua m√°gica! üòª</p>

<h2 id="flatmap"><code class="language-plaintext highlighter-rouge">flatMap</code></h2>

<p>Poder√≠amos implementar o <code class="language-plaintext highlighter-rouge">flatMap</code> usando <code class="language-plaintext highlighter-rouge">map</code> e desembrulhando o valor. Por√©m, √© mais f√°cil fazer uma implementa√ß√£o an√°loga √† do <code class="language-plaintext highlighter-rouge">map</code> sem reembrulhar o retorno:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@warn_unused_result</span>
<span class="kd">func</span> <span class="n">flatMap</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">f</span><span class="p">:</span> <span class="p">(</span><span class="kt">T</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">MyOptional</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span><span class="p">))</span> <span class="k">rethrows</span> <span class="o">-&gt;</span> <span class="kt">MyOptional</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="k">self</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">.</span><span class="kt">None</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="nv">mappedValue</span> <span class="o">=</span> <span class="k">try</span> <span class="nf">f</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mappedValue</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="implicitlyunwrappedoptionals"><code class="language-plaintext highlighter-rouge">ImplicitlyUnwrappedOptionals</code></h1>

<p><code class="language-plaintext highlighter-rouge">ImplicitlyUnwrappedOptional</code> √© o <strong>irm√£o malvado</strong> do <code class="language-plaintext highlighter-rouge">Optional</code>. Ele √© como um <code class="language-plaintext highlighter-rouge">Optional</code> mas, como o nome sugere, voc√™ consegue acessar seu valor sem precisar desembrulh√°-lo. O problema disso √©: se o valor n√£o existe o app crasha. A principal raz√£o de sua exist√™ncia √© para ponte com Objective-C.</p>

<p>A parte boa √©: voc√™ consegue usar ele como um <code class="language-plaintext highlighter-rouge">Optional</code>, ou seja, √© poss√≠vel fazer o desembrulho condicional, <em>Optional chaining</em> e at√© mesmo usar <em>nil coalescing</em>.</p>

<h2 id="iboutlet">IBOutlet</h2>

<p>O Xcode gosta de nos atrapalhar. Um dos jeitos dele de fazer isso excepcionalmente bem √©: quando criamos IBOutlets eles por padr√£o s√£o <code class="language-plaintext highlighter-rouge">ImplicitlyUnwrappedOptional</code>s. Voc√™ poderia contra-argumentar que se funciona na sua m√°quina vai funcionar sempre e isso √© o Xcode incentivando <em>fail-fast</em> para evitar que outlets sejam erroneamente desligados. Normalmente eu concordaria com voc√™, mas depois de ver <strong>diversos crashes</strong> (em projetos diferentes) por IBOutlets que estavam <code class="language-plaintext highlighter-rouge">nil</code> eu preferiria parar de arriscar.</p>

<p>Como mencionei antes eu poderia simplesmente trat√°-los como <code class="language-plaintext highlighter-rouge">Optional</code>s, mas como eu quero incentivar todos do meu time a fazerem isso criei um <a href="http://github.com/fpg1503/OptionalOutlets/">pluginzinho</a> para deix√°-los <code class="language-plaintext highlighter-rouge">Optional</code> automaticamente para mim! Se voc√™ preferir pode arrumar um por um, basta trocar o <code class="language-plaintext highlighter-rouge">!</code> por um <code class="language-plaintext highlighter-rouge">?</code>.</p>

<h1 id="optionals-e-boas-pr√°ticas">Optionals e boas pr√°ticas</h1>

<h2 id="evitar-a-piramyd-of-doom">Evitar a <em>Piramyd of Doom</em></h2>

<p>Vamos supor o seguinte caso</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span> <span class="o">=</span> <span class="s">"one"</span>
<span class="k">var</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span> <span class="o">=</span> <span class="s">"two"</span>
<span class="k">var</span> <span class="nv">c</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span> <span class="o">=</span> <span class="s">"three"</span>
</code></pre></div></div>

<p>Antigamente a √∫nica maneira de lidar com isso era:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="k">let</span> <span class="nv">aUnwrapped</span> <span class="o">=</span> <span class="n">a</span> <span class="p">{</span>
  <span class="k">if</span> <span class="k">let</span> <span class="nv">bUnwrapped</span> <span class="o">=</span> <span class="n">b</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">cUnwrapped</span> <span class="o">=</span> <span class="n">c</span> <span class="p">{</span>
      <span class="nf">println</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">aUnwrapped</span><span class="se">)</span><span class="s"> - </span><span class="se">\(</span><span class="n">bUnwrapped</span><span class="se">)</span><span class="s"> - </span><span class="se">\(</span><span class="n">cUnwrapped</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Por√©m a partir do Swift 1.2 podemos simplesmente fazer todos os desembrulhamentos de uma s√≥ vez:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="k">let</span> <span class="nv">aUnwrapped</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">bUnwrapped</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">cUnwrapped</span> <span class="o">=</span> <span class="n">c</span> <span class="p">{</span>
  <span class="nf">println</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">aUnwrapped</span><span class="se">)</span><span class="s"> - </span><span class="se">\(</span><span class="n">bUnwrapped</span><span class="se">)</span><span class="s"> - </span><span class="se">\(</span><span class="n">cUnwrapped</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="evitar-o-force-unwrap">Evitar o <strong>force unwrap</strong></h2>

<p><img src="/img/fpg1503/everytime.jpg" alt="" /></p>

<p>O <strong>force unwrap</strong> (ou desembrulho for√ßado) √© equivalente a dizer: <strong>eu tenho certeza que tem uma coisa aqui!</strong>. Se voc√™ estiver errado o app crasha.</p>

<blockquote>
  <p>Tenho um amigo que gosta de dizer que Optionals s√£o caixas que podem ter bombas dentro.</p>
</blockquote>

<p>Voc√™ abriria a caixa de uma vez ou faria um furinho primeiro para ver o que est√° l√°? Imaginei‚Ä¶</p>

<p>Se seus crashes come√ßarem a mostrar <code class="language-plaintext highlighter-rouge">EXC_BREAKPOINT</code> ou crashes na <code class="language-plaintext highlighter-rouge">linha 0</code> eu recomendaria come√ßar procurando algum force unwrap. Fique atento pois ele pode estar acontecendo sem que voc√™ perceba atrav√©s de um <code class="language-plaintext highlighter-rouge">ImplicitlyUnwrappedOptional</code>!</p>

<h3 id="n√£o-confiar-no-xcode">N√£o confiar no Xcode</h3>

<p>Como mencionamos antes, o Xcode gosta de nos atrapalhar: vive sugerindo que fa√ßamos o force unwrap, o que acaba gerando c√≥digos como o abaixo:</p>

<p><code class="language-plaintext highlighter-rouge">self?.collectionView?.indexPathsForSelectedItems()!</code></p>

<p>Esse √© o c√≥digo que chamamos popularmente de <strong>Swift Safad√£o</strong>
<img src="/img/fpg1503/99popt.jpg" alt="" /></p>

<p>O problema dele √© que se qualquer coisa n√£o existir, haver√° um crash. N√£o gostamos de crashes.</p>

<h3 id="quando-usar-force-unwrap">Quando usar force unwrap</h3>
<p>Idealmente? <strong>Nunca</strong>. Na pr√°tica? Depende do seu n√≠vel de desconfian√ßa. Se voc√™ est√° criando uma <code class="language-plaintext highlighter-rouge">NSURL</code> a partir de uma <code class="language-plaintext highlighter-rouge">String</code> constante e funciona em dev provavelmente n√£o haver√° problemas em produ√ß√£o. Pessoalmente eu gosto de checar sempre, se der errado eu normalmente logo um erro <strong>non-fatal</strong> para entender o que est√° acontecendo.</p>

<h2 id="nil-coalescing">Nil coalescing</h2>

<p>Muitas vezes a melhor maneira de lidar com um <code class="language-plaintext highlighter-rouge">Optional</code> √© dando um valor para padr√£o para ele, para isso podemos usar o operador de nil coalescing:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="n">someOptionalObject</span><span class="p">?</span><span class="o">.</span><span class="n">someOptionalValue</span> <span class="p">??</span> <span class="n">defaultValue</span>
</code></pre></div></div>

<h1 id="em-suma">Em suma</h1>

<p>Opcionalidade √© diferente de nulabilidade e tentar tratar os dois como a mesma coisa pode te levar a fazer muitos erros. <code class="language-plaintext highlighter-rouge">Optional</code> √© um tipo e ele te d√° <em>type-safety</em> do que pode n√£o existir.</p>

<p>Optionals te trazem mais seguran√ßa e te livram de muita dor de cabe√ßa. Vamos supor que haja uma sequ√™ncia de <code class="language-plaintext highlighter-rouge">n</code> fun√ß√µes chamadas de maneira aninhada para processar um valor. Em linguagens sem Optionals, temos que tratar a aus√™ncia desse valor em todas as chamadas. J√° nas com Optionals, basta tratar este caso nas mais externas. O fato de <code class="language-plaintext highlighter-rouge">Optional</code> ser um tipo distinto garante que nenhuma das outras chamadas sejam executadas com um valor que n√£o existe.</p>

<p>O desembrulho for√ßado √© incrivelmente perigoso e os opcionais desembrulhados implicitamente s√£o <strong>being evil for no reason</strong>. Evite us√°-los, seu <em>crash-free</em> (e seus usu√°rios) agradecem.</p>

<p>Essa mudan√ßa veio por um motivo: devemos mudar nosso <em>mindset</em>. Quando come√ßamos a pensar com Optionals o mundo fica mais lindo.</p>

<p>Optionals s√£o caixas como a do experimento de Schr√∂dinger: at√© abrir n√£o temos certeza do estado de seu conte√∫do.</p>

<h1 id="imagens">Imagens</h1>

<blockquote>
  <ul>
    <li>As imagens dos Emojis foram fornecidas pelo <a href="http://emojione.com">EmojiOne</a></li>
    <li>O gato da foto de capa do post √© meu sobrinho <a href="https://instagram.com/mozziethekitten" target="_blank">Mozzie</a>)</li>
  </ul>
</blockquote>


                <hr>

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/ios/2016/03/23/fastlane/" data-toggle="tooltip" data-placement="top" title="Fastlane">&larr; Post Anterior</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/frameworks/2016/03/25/criando-frameworks/" data-toggle="tooltip" data-placement="top" title="Criando frameworks para v√°rias plataformas">Pr√≥ximo Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- Disqus Content -->

                <div id="disqus_thread">
                    <script>
                        /**
                        * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
                        * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
                        */

                        /*
                        var disqus_config = function () {
                            this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
                            this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                        };
                        */

                        (function() { // DON'T EDIT BELOW THIS LINE
                        var d = document, s = d.createElement('script');

                        s.src = '//equinocios.disqus.com/embed.js';

                        s.setAttribute('data-timestamp', +new Date());
                        (d.head || d.body).appendChild(s);
                        })();
                    </script>
                    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
                </div>

            </div>
        </div>
    </div>
</article>

<hr>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                </ul>
                <p class="copyright text-muted">A odisseia do puto ‚Äî Raimundo Pessoa & Frederico Do</p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/clean-blog.min.js "></script>


</body>

</html>
