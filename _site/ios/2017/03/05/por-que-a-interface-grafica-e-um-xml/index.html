<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Blog de tecnologia e desenvolvimento — artigos, tutoriais e opinião.">

    <title>Por que a interface gráfica é um XML? - A odisseia do puto</title>

    <link rel="canonical" href="http://localhost:4000/ios/2017/03/05/por-que-a-interface-grafica-e-um-xml/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/clean-blog.css">
    <link rel="stylesheet" href="/css/odisseia.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
    
    <!-- Share CSS -->
    <link rel="stylesheet" href="/css/share.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="A odisseia do puto" />

    

</head>


<body>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">A odisseia do puto</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
				
                <li>
                    <a href="/about/">Sobre</a>
                </li>
				
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


    <!-- Post Header -->
<header class="intro-header">
    <div class="intro-header-overlay">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>Por que a interface gráfica é um XML?</h1>
                        
                        <h2 class="subheading">Entenda um pouco da programação por definições</h2>
                        
                        <span class="meta">Postado por Ronaldo Faria Lima em 05/03/2017</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="share">
  <li><a href="https://twitter.com/intent/tweet?text=Por que a interface gráfica é um XML?&url=http://localhost:4000/ios/2017/03/05/por-que-a-interface-grafica-e-um-xml/" rel="nofollow" target="_blank" title="Share on Twitter"><i class="fa fa-twitter-square"></i></a></li>
  <li><a href="https://facebook.com/sharer.php?u=http://localhost:4000/ios/2017/03/05/por-que-a-interface-grafica-e-um-xml/" rel="nofollow" target="_blank" title="Share on Facebook"><i class="fa fa-facebook-square"></i></a></li>
  <li><a href="http://www.linkedin.com/shareArticle?mini=true&url=http://localhost:4000/ios/2017/03/05/por-que-a-interface-grafica-e-um-xml/" rel="nofollow" target="_blank" title="Share on Linkedlin"><i class="fa fa-linkedin-square"></i></a></li>
  <li><a href="https://plus.google.com/share?url=http://localhost:4000/ios/2017/03/05/por-que-a-interface-grafica-e-um-xml/" rel="nofollow" target="_blank" title="Share on Google+"><i class="fa fa-google-plus-square"></i></a></li>
</ul>

				<p>Antes da interface gráfica o mundo era feito de caracteres. A interface primária
com os computadores era através de uma tela de texto. À medida em que os
sistemas foram aumentando a quantidade de funcionalidades, as telas simples
tornavam-se um estorvo para o usuário. Assim, surgiram as aplicações orientadas
a menus. A barra de menus, que normalmente ficava no topo da tela, foi uma
grande novidade durante um tempo. Os menus começaram a ficar complicados, cheios
de níveis, de opções, de teclas de atalho. A interface caractere havia atingido
seu limite.</p>

<p>Até então, criar telas era simples. Era relativamente fácil criar funções para
desenhar janelas, controlar o mouse. Sem dúvida, exigia programação de baixo
nível. Por exemplo, para iniciar o driver do mouse era necessário realizar uma
interrupção de software que provocava a ativação do mouse. Para criar sombras
abaixo de menus, era necessário acessar a RAM de vídeo na página 0 e mudar os
atributos dos caracteres, como o valor de intensidade luminosa. Apesar de serem
práticas de baixo nível, não era difícil fazer isso. Uma vez escrita a função,
era fácil reutilizá-la.</p>

<p>Linguagens como dBase III, Foxbase e Clipper já vinham com uma série de funções
prontas para traçar a interface com o usuário. Basicamente, a interface era
criada via código. Nos sistemas unix havia, e ainda há, uma biblioteca chamada
<em>curses</em> que permite ao programador controlar aspectos interessantes de um
terminal texto. Os terminais texto usam sequências de escape, ou seja,
sequências binárias que criam comportamentos interessantes, como ajustar a cor
de fundo de um texto ou o brilho sem a necessidade de gerar, manualmente, todas
as sequências binárias necessárias.</p>

<p>E aí chegou a interface gráfica. As telas deixaram de ser retangulares. Há
programas que criam janelas em formatos diversos. Porém, programar a interface
de um programa tornou-se uma tarefa hedionda. Escrever por código tudo o que era
necessário para criar efeitos como sombras, profundidade, textura, animações
ficou aburdamente complicado. Bibliotecas gráficas e SDKs como a Motiff, Win32,
MFC e OWL tentavam ajudar, mas mesmo assim a tarefa de escrever código era bem
complexa, apesar de ser uma repetição interminável.</p>

<p>Bem, agora chegamos onde queríamos: por que minha interface gráfica virou um
XML? Este blablablá todo foi para contextualizar a dificuldade que é criar uma
interface gráfica. Deveria haver alguma forma de simplificar este trabalho dos
infernos. E foi aí que alguém teve a brilhante ideia de começar a usar
representações para governar o comportamento do software que traçava os gráficos
da interface com o usuário.</p>

<h2 id="borland-x-microsoft">Borland x Microsoft</h2>

<p>A Microsoft percebeu que seus programadores sofriam horrores com o seu SDK para
fazer aplicações para o seu ambiente operacional gráfico. Sim, estou falando do
Windows antes de tornar-se um sistema operacional de fato. Foi quando surgiram
os arquivos <em>res</em>. Os scripts de recursos permitiam ao programador criar ícones,
menus e janelas. A ideia era simplificar o trabalho do programador deixando-o
com uma linguagem mais simples que, ao ser interpretada, permitisse que a
interface fosse criada com mais facilidade.</p>

<p>Os arquivos <em>res</em> eram efetivamente compilados e geravam todo o código
necessário para que seu conteúdo fosse exibido corretamente para o usuário
final. Isto foi uma grande evolução, mas a interface ainda continuava bem
complicada para ser criada. Começaram a surgir editores gráficos que geravam os
arquivos <em>res</em>, mas eram de uso complexo.</p>

<p>Com o avanço das linguagens visuais, em particular com o Visual Basic, os
arquivos de representação começaram a ser usados com mais frequência. A Borland,
indo nesta onda, lançou em 1995 o Borland Delphi que levou ao uso dos arquivos
de representação para outro nível. As telas eram criadas em arquivos-texto ou
binários que eram lidos pelo <em>run-time</em>, interpretados e apresentados ao
usuário. Criar interfaces gráficas havia se tornado um exercício de arrastar e
soltar.</p>

<h2 id="next-e-o-interface-builder">NeXT e o Interface Builder</h2>

<p>Quase 10 anos antes do Delphi sair quebrando tudo no mercado de desenvolvimento,
em 1986, um francês chamado Jean-Marie Hullot, escreveu um editor de interfaces
gráficas usando a linguagem LISP. Este editor também usava arquivos de
representação para descrever como a interface gráfica deveria ser construída em
<em>run-time</em>. Steve Jobs, em 1987, conheceu Jean-Marie e incorporou esta
facilidade no <em>toolbox</em> de desenvolvimento da NeXT, para simplificar o
desenvolvimento de interfaces gráficas para os programadores que desenvolviam
para o NeXTStep.</p>

<p>Assim, os programadores podiam usar uma ferramenta gráfica para criar seus
projetos e depois incorporá-los nos seus sistemas sem a necessidade de escrever
toneladas de código, a grande maioria código repetitivo e hoje conhecido como
<em>boiler plate</em>.</p>

<h2 id="por-que-xml">Por que XML?</h2>

<p>Até então cada solução usava uma forma proprietária para descrever os dados
necessários para fornecer às bibliotecas para que estas pudessem realizar seu
trabalho. Porém, em 1996, apareceu o XML como uma solução simples e portável
para criação de documentos estruturados, qualquer que fosse a estrutura desejada
para organizar a informação.</p>

<p>Com o aparecimento do XML e, consequentemente dos <em>parsers</em>, diversos frameworks
começaram a usá-lo para configuração ou processamento de instruções. O XML é
suficientemente simples e igualmente completo no que diz respeito às
representações possíveis com a linguagem. Assim, pode-se salvar virtualmente
qualquer representação em uma estrutura XML.</p>

<h2 id="xib-nib">XIB? NIB?</h2>

<p>Bem, depois desse tanto de história, sabemos por que a Apple usa o formato XML
para os arquivos XIB. Estes arquivos contém representações que determinam como
uma view ou janela serão criadas, bem como o que será chamado quando houver
algum tipo de interação com o usuário. Porém, o que diferencia o NIB do XIB?</p>

<p>O arquivo NIB tem um formato binário, formato este que era usado antes do
surgimento do XML no mercado. A princípio, por uma questão de compatibilidade, o
XIB é convertido em NIB e é o NIB quem alimenta os frameworks gráficos da
Apple. No entanto, há outro motivo para haver esta transformação: O XML, apesar
de muito flexível, tende ter um processo de interpretação complexo, que pode
consumir CPU e memória. Apesar do NIB ser um formato antigo, trata-se de um
formato muito mais eficiente em termos de interpretação e execução em relação ao
XML.</p>

<p>Atualmente existem os <em>push parsers</em> XML que são mais eficientes e econômicos
que os <em>parsers</em> baseados em DOM. No entanto, nada é mais eficiente que uma
representação binária que pode ser lida em blocos, como é o caso dos arquivos
NIB.</p>

<h1 id="o-poder-da-representação">O poder da representação</h1>

<p>A ideia de usar representações para programar não é novidade. Em seu excelente
livro <em>“The Practice of Programming”</em>, Brian W. Kernighan, um dos pais da
linguagem C, apresenta algumas ideias sobre o uso de representações em
linguagens de programação, em particular em algumas funções da biblioteca STDC e
da linguagem de scripting <em>awk</em>.</p>

<p>A ideia é simples: dada uma representação arbitrária, um código que a interprete
terá um comportamento bem definido se esta representação fizer parte da
gramática reconhecida por este código. Assim é como funcionam os arquivos
XIB/NIB: eles definem sua interface gráfica em termos de estrutura visual e
comportamento, permitindo que métodos arbitrários pertencentes à classes
arbitrárias possam ser chamados quando houver algum tipo de interação com o
usuário.</p>

<p>O que se consegue com isto é um código amplamente flexível, que pode ser
facilmente customizado e usado em diversos contextos diferentes sem, contudo,
exigir reprogramação do mesmo. Como exemplo, veja a função da bibilioteca STDC
<em>printf</em>. É possível fazer virtualmente qualquer saída formatada com esta
função. O comportamento da formatação está descrito na string de máscara que tem
uma gramática simples e muito limitada mas não menos poderosa.</p>

<p>Este mesmo efeito é observado no Cocoa e no Cocoa Touch no que diz respeito ao
processamento de arquivos XIB/NIB. É possível construir uma combinação enorme de
telas sem a necessidade de customizar as classes que representam as views. Isto
faz com que o código torne-se bastante flexível a ponto de existirem casos de
desenvolvedores que nunca precisaram customizar a classe de uma view para
desenhar alguma coisa que o framework não suportava desenhar.</p>

<p>Sem dúvida, cedo ou tarde todo desenvolvedor precisará especializar alguma
classe visual do UIKit. No entanto, é possível criar comportamentos altamente
customizados apenas usando as classes fornecidas, o que demonstra o poder que
uma representação pode ter.</p>

<h1 id="concluindo">Concluindo…</h1>

<p>A sua interface gráfica é construída com base em um XML por que a linguagem de
marcação é simples, poderosa e permite representar virtualmente qualquer
combinação possível de elementos. Dentro do universo Apple, o Xcode ainda
permite representar nos seus XMLs classes customizadas que podem ter suas
propriedades editadas no Interface Builder.</p>

<p>Ao representar em um documento como a sua interface deve ficar, economiza-se
muito código, deixando para o framework todo o <em>heavy lifting</em> necessário para
desenhar e dar comportamento à interface gráfica.</p>


                <hr>

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/arquitetura/2017/03/02/Introducao-a-arquitetura-evolutiva/" data-toggle="tooltip" data-placement="top" title="Introdução a Arquitetura Evolutiva">&larr; Post Anterior</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/testes/2017/03/06/unit-tests-101/" data-toggle="tooltip" data-placement="top" title="Unit Tests 101">Próximo Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- Disqus Content -->

                <div id="disqus_thread">
                    <script>
                        /**
                        * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
                        * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
                        */

                        /*
                        var disqus_config = function () {
                            this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
                            this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                        };
                        */

                        (function() { // DON'T EDIT BELOW THIS LINE
                        var d = document, s = d.createElement('script');

                        s.src = '//equinocios.disqus.com/embed.js';

                        s.setAttribute('data-timestamp', +new Date());
                        (d.head || d.body).appendChild(s);
                        })();
                    </script>
                    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
                </div>

            </div>
        </div>
    </div>
</article>

<hr>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                </ul>
                <p class="copyright text-muted">A odisseia do puto — Raimundo Pessoa & Frederico Do</p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/clean-blog.min.js "></script>


</body>

</html>
