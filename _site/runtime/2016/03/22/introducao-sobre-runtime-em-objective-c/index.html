<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Blog de tecnologia e desenvolvimento — artigos, tutoriais e opinião.">

    <title>Introdução sobre Runtime em Objective-C - A odisseia do puto</title>

    <link rel="canonical" href="http://localhost:4000/runtime/2016/03/22/introducao-sobre-runtime-em-objective-c/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/clean-blog.css">
    <link rel="stylesheet" href="/css/odisseia.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
    
    <!-- Share CSS -->
    <link rel="stylesheet" href="/css/share.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="A odisseia do puto" />

    

</head>


<body>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">A odisseia do puto</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
				
                <li>
                    <a href="/about/">Sobre</a>
                </li>
				
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


    <!-- Post Header -->
<header class="intro-header">
    <div class="intro-header-overlay">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>Introdução sobre Runtime em Objective-C</h1>
                        
                        <h2 class="subheading"></h2>
                        
                        <span class="meta">Postado por Fernanda Gadeia Geraissate em 22/03/2016</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="share">
  <li><a href="https://twitter.com/intent/tweet?text=Introdução sobre Runtime em Objective-C&url=http://localhost:4000/runtime/2016/03/22/introducao-sobre-runtime-em-objective-c/" rel="nofollow" target="_blank" title="Share on Twitter"><i class="fa fa-twitter-square"></i></a></li>
  <li><a href="https://facebook.com/sharer.php?u=http://localhost:4000/runtime/2016/03/22/introducao-sobre-runtime-em-objective-c/" rel="nofollow" target="_blank" title="Share on Facebook"><i class="fa fa-facebook-square"></i></a></li>
  <li><a href="http://www.linkedin.com/shareArticle?mini=true&url=http://localhost:4000/runtime/2016/03/22/introducao-sobre-runtime-em-objective-c/" rel="nofollow" target="_blank" title="Share on Linkedlin"><i class="fa fa-linkedin-square"></i></a></li>
  <li><a href="https://plus.google.com/share?url=http://localhost:4000/runtime/2016/03/22/introducao-sobre-runtime-em-objective-c/" rel="nofollow" target="_blank" title="Share on Google+"><i class="fa fa-google-plus-square"></i></a></li>
</ul>

				<h1 id="introdução-sobre-runtime-em-objective-c">Introdução sobre Runtime em Objective-C</h1>

<p>Alguns leitores estão familiarizados com bibliotecas como <a href="https://github.com/specta/specta">Specta</a>, <a href="http://ocmock.org/">OCMock</a> e <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>. O que em um primeiro momento pode parecer mágica, estas ferramentas na verdade exploram ao máximo o fato do Objective-C ser uma linguagem dinâmica, isto é, o código em questão toma decisões em tempo de execução (“runtime”) <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1">sempre que possível</a>.</p>

<p><img src="/img/fggeraissate/bobruntime.jpg" alt="" /></p>

<p>Isto fornece uma flexibilidade que pode ser aproveitada de diversas maneiras. Uma das mais conhecidas é consultar informações sobre um dado objeto, através de métodos como <code class="language-plaintext highlighter-rouge">isKindOfClass:</code>, <code class="language-plaintext highlighter-rouge">respondsToSelector:</code>, <code class="language-plaintext highlighter-rouge">conformsToProtocol:</code> e assim por diante. Pode-se também adicionar novos métodos, chamá-los e até mudar a sua implementação em runtime. Isto é comumente utilizado no OCMock, quando, por exemplo, um objeto “mockado” não mais depende de um serviço para obter a resposta de uma chamada, e sim, retorna um JSON que foi previamente setado.</p>

<p>Embora o runtime funcione na maior parte do tempo por debaixo dos panos, é interessante estudar mais sobre o assunto não só para entender melhor como a estrutura da linguagem funciona mas também para entender a razão pela qual alguns passos são realizados.</p>

<p>Aqui será mostrado uma visão geral sobre o assunto, para mais detalhes é recomendado ler o “<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1">Objective-C Runtime Programming Guide</a>”.</p>

<h2 id="algumas-definições">Algumas definições</h2>

<p>Para saber como o runtime funciona é importante entender algumas definições. Selector, método e implementação podem num primeiro momento parecer que são a mesma coisa, mas na verdade são diferentes etapas de um processo feito em tempo de execução. Os termos mais importantes serão descritos abaixo. Não esqueça de importar a biblioteca <code class="language-plaintext highlighter-rouge">&lt;objc/runtime.h&gt;</code> caso queira explorar os parâmetros a seguir.</p>

<h3 id="selector">Selector</h3>

<p>Um <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/c/tdef/SEL">selector</a> (<code class="language-plaintext highlighter-rouge">typedef struct objc_selector *SEL</code>) nada mais é do que o nome de um método, como por exemplo <code class="language-plaintext highlighter-rouge">viewDidAppear:</code>, <code class="language-plaintext highlighter-rouge">setObject:forKey:</code>, etc. Note que o “:” faz parte do selector e serve para identificar quando é preciso passar parâmetros para um método. Para trabalhar diretamente com um selector, basta fazer, por exemplo:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SEL</span> <span class="n">selector</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="n">viewDidAppear</span><span class="o">:</span><span class="p">)</span>
<span class="c1">//ou</span>
<span class="n">SEL</span> <span class="n">aSelector</span> <span class="o">=</span> <span class="n">NSSelectorFromString</span><span class="p">(</span><span class="s">@"viewDidAppear:"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="method">Method</h3>

<p>Um <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/c/tdef/Method">método</a> (<code class="language-plaintext highlighter-rouge">typedef struct objc_method *Method</code>) é a combinação de um selector e sua implementação. Para acessar um método de uma instância ou classe, basta fazer:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Instance Method</span>
<span class="n">Class</span> <span class="n">class</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">class</span><span class="p">];</span>
<span class="n">Method</span> <span class="n">method</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">class</span><span class="p">,</span> <span class="n">selector</span><span class="p">);</span>

<span class="c1">// Class Method</span>
<span class="n">Class</span> <span class="n">class</span> <span class="o">=</span> <span class="n">object_getClass</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="n">Method</span> <span class="n">method</span> <span class="o">=</span> <span class="n">class_getClassMethod</span><span class="p">(</span><span class="n">class</span><span class="p">,</span> <span class="n">selector</span><span class="p">);</span>
</code></pre></div></div>

<p>O método <code class="language-plaintext highlighter-rouge">class_getInstanceMethod(class, selector)</code> retorna o método de instância que corresponde a implementação de um selector em uma dada classe, ou NULL, caso, por exemplo, a classe ou a classe pai não tiver o método de instância para um selector específico.</p>

<h3 id="implementation">Implementation</h3>

<p>Uma <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/c/tag/IMP">implementação</a> (<code class="language-plaintext highlighter-rouge">id (*IMP)(id, SEL, …</code>)) é basicamente o que está escrito dentro do bloco de um código. Um objeto do tipo IMP é um tipo de dado que aponta para o início da função que implementa o método. O primeiro argumento (id) aponta para a memória de uma dada instância de uma classe (ou no caso de um método de classe, um ponteiro para uma <a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html">metaclasse</a>), também chamado de “receiver” (aquele que recebe o método), o segundo é o nome do método (SEL) e os restantes são os parâmetros que um método requere. A implementação pode ser adquirida da seguinte forma:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">IMP</span> <span class="n">implementation</span> <span class="o">=</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">method</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="message">Message</h3>

<p>Enviar uma <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/doc/uid/TP40001418-CH1g-88778">mensagem</a> é invocar um selector junto com os parâmetros que serão enviados para um “receiver”. Por exemplo, ao fazer:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">button</span> <span class="nf">setTitle</span><span class="p">:</span><span class="s">@"title"</span> <span class="nf">forState</span><span class="p">:</span><span class="n">UIControlStateNormal</span><span class="p">];</span>
</code></pre></div></div>

<p>o compilador chama a seguinte função:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">objc_msgSend</span><span class="p">(</span><span class="n">button</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">setTitle</span><span class="o">:</span><span class="n">forState</span><span class="o">:</span><span class="p">),</span> <span class="s">@"title"</span><span class="p">,</span> <span class="n">UIControlStateNormal</span><span class="p">);</span>
</code></pre></div></div>

<p>e, assim, a mensagem enviada para o “receiver” button é o selector “setTitle:forState:” mais os argumentos “title” e “UIControlStateNormal”. É possível guardar uma mensagem em um objeto do tipo <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSInvocation_Class/">NSInvocation</a> para invocá-la posteriormente.</p>

<h3 id="method-signature">Method Signature</h3>

<p>A assinatura de um método (<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSMethodSignature_Class/">NSMethodSignature</a>) representa os tipos de dados que são aceitos e retornados por um método. Pode ser obtido por:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NSMethodSignature</span> <span class="o">*</span><span class="n">signature</span> <span class="o">=</span> <span class="p">[</span><span class="n">receiver</span> <span class="nf">methodSignatureForSelector</span><span class="p">:</span><span class="n">selector</span><span class="p">];</span>
</code></pre></div></div>

<p>onde o receiver é o objeto que implementa o método e o selector é o nome do método, como já foi discutido anteriormente.</p>

<h3 id="invocation">Invocation</h3>

<p>Um objeto do tipo <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSInvocation_Class/">NSInvocation</a> é usado para guardar e enviar mensagens para um dado objeto. Ele contém todos os elementos necessários para enviar uma mensagem: um “receiver”, um selector, parâmetros de envio e o valor que será retornado. Um exemplo de como implementar um objeto desse tipo é:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">invokeSelector</span><span class="p">(</span><span class="n">id</span> <span class="n">receiver</span><span class="p">,</span> <span class="n">SEL</span> <span class="n">selector</span><span class="p">,</span> <span class="n">NSArray</span> <span class="o">*</span><span class="n">arrayArguments</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">receiver</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="o">&amp;&amp;</span> <span class="p">[</span><span class="n">receiver</span> <span class="nf">respondsToSelector</span><span class="p">:</span><span class="n">selector</span><span class="p">])</span> <span class="p">{</span>
        
        <span class="n">NSMethodSignature</span> <span class="o">*</span><span class="n">signature</span> <span class="o">=</span> <span class="p">[</span><span class="n">receiver</span> <span class="nf">methodSignatureForSelector</span><span class="p">:</span><span class="n">selector</span><span class="p">];</span>
        <span class="n">NSInvocation</span> <span class="o">*</span><span class="n">invocation</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSInvocation</span> <span class="nf">invocationWithMethodSignature</span><span class="p">:</span><span class="n">signature</span><span class="p">];</span>
        <span class="p">[</span><span class="n">invocation</span> <span class="nf">setTarget</span><span class="p">:</span><span class="n">receiver</span><span class="p">];</span>
        <span class="p">[</span><span class="n">invocation</span> <span class="nf">setSelector</span><span class="p">:</span><span class="n">selector</span><span class="p">];</span>
        
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">[</span><span class="n">signature</span> <span class="nf">numberOfArguments</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">id</span> <span class="n">arg</span> <span class="o">=</span> <span class="p">[</span><span class="n">arrayArguments</span> <span class="nf">objectAtIndex</span><span class="p">:</span><span class="n">i</span><span class="p">];</span>
            <span class="p">[</span><span class="n">invocation</span> <span class="nf">setArgument</span><span class="p">:</span><span class="o">&amp;</span><span class="n">arg</span> <span class="nf">atIndex</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// The first two arguments are the hidden arguments self and _cmd</span>
        <span class="p">}</span>
        
        <span class="p">[</span><span class="n">invocation</span> <span class="nf">invoke</span><span class="p">];</span> <span class="c1">// Invoke the selector</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">invocationExample</span> <span class="p">{</span>

    <span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">dictionary</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableDictionary</span> <span class="nf">new</span><span class="p">];</span>
    <span class="n">invokeSelector</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="n">NSSelectorFromString</span><span class="p">(</span><span class="s">@"setObject:forKey:"</span><span class="p">),</span> <span class="p">@[</span><span class="s">@"keyString"</span><span class="p">,</span> <span class="s">@"valueString"</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note que os argumentos são setados a partir do índice 2. Isto porque os índices 0 e 1 são reservados para os argumentos self e _cmd, respectivamente, e devem ser setados explicitamente como mostrado acima, onde self é igual ao receiver e _cmd é o selector.</p>

<p>Se o leitor estiver familiarizado com testes unitários e usou o OCMock, já deve ter se deparado com a seguinte situação:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[[[</span><span class="n">managerMock</span> <span class="nf">expect</span><span class="p">]</span> <span class="nf">andDo</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSInvocation</span> <span class="o">*</span><span class="n">invocation</span><span class="p">)</span> <span class="p">{</span>

        <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">successBlock</span><span class="p">)(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">aString</span><span class="p">)</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
        <span class="p">[</span><span class="n">invocation</span> <span class="nf">getArgument</span><span class="p">:</span><span class="o">&amp;</span><span class="n">successBlock</span> <span class="nf">atIndex</span><span class="p">:</span><span class="mi">2</span><span class="p">];</span>
        
        <span class="n">successBlock</span><span class="p">(</span><span class="s">@"42"</span><span class="p">);</span>
        
<span class="p">}]</span> <span class="nf">successBlock</span><span class="p">:[</span><span class="n">OCMArg</span> <span class="nf">any</span><span class="p">]</span> <span class="nf">errorBlock</span><span class="p">:[</span><span class="n">OCMArg</span> <span class="nf">any</span><span class="p">]];</span>
</code></pre></div></div>

<p>No caso, o objeto manager terá o retorno do bloco de resposta “mockado” toda vez que o método <code class="language-plaintext highlighter-rouge">successBlock:errorBlock:</code> for chamado. Note que o primeiro argumento é referenciado com o índice 2, o segundo a 3 e assim por diante (caso houvesse), devido ao fato do que foi discutido acima.</p>

<h2 id="juntando-o-quebra-cabeça">Juntando o quebra-cabeça</h2>

<p>Com estas definições em mente fica mais fácil entender como o processo em runtime funciona e como estes conceitos estão relacionados. </p>

<p>No Objective-C, a estrutura de uma classe possui:</p>

<ul>
  <li>Um ponteiro para a classe pai (ou superclass)</li>
  <li>Uma “dispatch table”, onde cada entrada associa um selector a uma implementação.</li>
</ul>

<p>Os objetos instanciados por sua vez possuem um ponteiro para a estrutura de classe, chamado <code class="language-plaintext highlighter-rouge">isa</code>, que dá ao objeto acesso a sua classe e, por meio da classe, a todas as classes que herda. Ao enviar uma mensagem a um objeto, a função <code class="language-plaintext highlighter-rouge">objc_msgSend(receiver, selector, arg1, arg 2, etc…)</code> segue o isa que aponta para a estrutura de classe e tenta encontrar o selector na “dispatch table”. Caso não encontre, a função segue o ponteiro que aponta para a superclass e tenta encontrar o selector na “dispatch table” dela. Falhas sucessivas fazem com que <code class="language-plaintext highlighter-rouge">objc_msgSend</code> vá subindo na hierarquia de classes até chegar na classe NSObject. Uma vez localizado o selector, o <code class="language-plaintext highlighter-rouge">objc_msgSend</code> chama o método correspondente e repassa os parâmetros, caso contrário, ocorre uma exceção. Dessa forma as implementações são escolhidas em tempo de execução.</p>

<p><img src="/img/fggeraissate/messaging.gif" alt="" />
<span class="caption text-muted">Créditos: https://developer.apple.com</span></p>

<p>Para acelerar o processo o sistema possui um cache para cada classe, que associa os selectors às implementações assim que vão sendo usadas. Quando uma mensagem for enviada, a função <code class="language-plaintext highlighter-rouge">objc_msgSend</code> checa primeiro esse cache antes de verificar a “dispatch table”. Assim quanto mais tempo o programa for executado, mais rapidamente as mensagens serão enviadas.</p>

<h2 id="método-swizzling">Método Swizzling</h2>

<p>Uma das formas de se aplicar esses conceitos sobre runtime é através do método Swizzling, que consiste em modificar a “dispatch table”, trocando selectors e implementações de dois métodos entre si.</p>

<p>Imagine que se queira, por exemplo, adicionar um log toda vez que uma tela aparece:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidAppear</span><span class="p">:(</span><span class="n">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
    
    <span class="p">[</span><span class="n">super</span> <span class="nf">viewDidAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
    
    <span class="p">[</span><span class="n">self</span> <span class="nf">writeLogWhenTheViewAppeared</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">writeLogWhenTheViewAppeared</span> <span class="p">{</span>
    
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"The view of viewController %@ appeared"</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Agora imagine repetir este processo para uma UIViewController, UITableViewController, UINavigationViewController, etc. A técnica mostrada a seguir visa evitar esse tipo de repetição.</p>

<p>Resumidamente, será implementado o método <code class="language-plaintext highlighter-rouge">extensionViewDidAppear:</code> (que conterá a implementação do log) e será trocado a implementação dele com o do <code class="language-plaintext highlighter-rouge">viewDidAppear:</code>. Assim quando for enviado a mensagem para a viewController com o selector <code class="language-plaintext highlighter-rouge">viewDidAppear:</code>, será na verdade executado a implementação de <code class="language-plaintext highlighter-rouge">extensionViewDidAppear:</code>. Além do log, o método <code class="language-plaintext highlighter-rouge">extensionViewDidAppear:</code> irá chamar <code class="language-plaintext highlighter-rouge">[self extensionViewDidAppear:]</code>. Como os selectors estão trocados, a implementação de <code class="language-plaintext highlighter-rouge">viewDidAppear:</code> será executada e o processo poderá continuar normalmente. O código a seguir pode ser encontrado no <a href="https://github.com/fggeraissate/FGSwizzlingExample">Github</a>.</p>

<p>O primeiro passo é criar uma categoria e importar a biblioteca <code class="language-plaintext highlighter-rouge">&lt;objc/runtime.h&gt;</code>:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#import "UIViewController+Swizzling.h"
</span>
<span class="cp">#import &lt;objc/runtime.h&gt;
</span>
<span class="k">@implementation</span> <span class="nc">UIViewController</span> <span class="p">(</span><span class="nl">Swizzling</span><span class="p">)</span>
</code></pre></div></div>

<p>O método a seguir aplicará a técnica Swizzling propriamente dita:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma mark - Swizzling viewDidAppear:
</span>
<span class="k">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">swizzlingViewDidAppear</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Dentro deste método será escrito:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Class</span> <span class="n">class</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">class</span><span class="p">];</span>
    
<span class="n">SEL</span> <span class="n">selectorOriginal</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="n">viewDidAppear</span><span class="o">:</span><span class="p">);</span>
<span class="n">SEL</span> <span class="n">selectorSwizz</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="n">extensionViewDidAppear</span><span class="o">:</span><span class="p">);</span>
    
<span class="n">Method</span> <span class="n">methodOriginal</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">class</span><span class="p">,</span> <span class="n">selectorOriginal</span><span class="p">);</span>
<span class="n">Method</span> <span class="n">methodSwizz</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">class</span><span class="p">,</span> <span class="n">selectorSwizz</span><span class="p">);</span>

 <span class="cm">/*
     Class class = object_getClass(self);
     
     SEL selectorOriginal = @selector(...);
     SEL selectorSwizz = @selector(...);
     
     Method methodOriginal = class_getClassMethod(class, selectorOriginal);
     Method methodSwizz = class_getClassMethod(class, selectorSwizz);
*/</span>
</code></pre></div></div>

<p>Primeiro é resgatado a classe do objeto no qual o método <code class="language-plaintext highlighter-rouge">viewDidAppear:</code> é implementado. Depois, guarda-se os selectors e métodos de <code class="language-plaintext highlighter-rouge">viewDidAppear:</code> e <code class="language-plaintext highlighter-rouge">extensionViewDidAppear:</code>. As linhas comentadas acima mostram como fazer este mesmo processo para métodos de classe. Feito isso será pego a implementação dos respectivos métodos:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">IMP</span> <span class="n">implementationOriginal</span> <span class="o">=</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">methodOriginal</span><span class="p">);</span>
<span class="n">IMP</span> <span class="n">implementationSwizz</span> <span class="o">=</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">methodSwizz</span><span class="p">);</span>
</code></pre></div></div>

<p>Agora será feito uma tentativa de adicionar à classe UIViewController (class) um método com o nome de <code class="language-plaintext highlighter-rouge">viewDidAppear:</code> (selectorOriginal), mas com a implementação de <code class="language-plaintext highlighter-rouge">extensionViewDidAppear:</code>. O último parâmetro trata-se de <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">um array de caracteres que correspondem aos tipos dos argumentos que serão passados para o método</a>.</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="n">didAddMethod</span> <span class="o">=</span> <span class="n">class_addMethod</span><span class="p">(</span><span class="n">class</span><span class="p">,</span>
                                    <span class="n">selectorOriginal</span><span class="p">,</span>
                                    <span class="n">implementationSwizz</span><span class="p">,</span>
                                    <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">methodSwizz</span><span class="p">));</span>
</code></pre></div></div>

<p>Em caso de sucesso, o próximo passo será fazer com que a classe em questão adicione um método com o nome de <code class="language-plaintext highlighter-rouge">extensionViewDidAppear:</code> mas com a implementação do método original. Caso contrário, significa que a classe já contém uma implementação com o dado nome. Neste caso, é necessário apenas trocar suas implementações:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">didAddMethod</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">class_replaceMethod</span><span class="p">(</span><span class="n">class</span><span class="p">,</span>
                            <span class="n">selectorSwizz</span><span class="p">,</span>
                            <span class="n">implementationOriginal</span><span class="p">,</span>
                            <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">methodOriginal</span><span class="p">));</span>
        
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">method_exchangeImplementations</span><span class="p">(</span><span class="n">methodOriginal</span><span class="p">,</span> <span class="n">methodSwizz</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Agora é preciso escrever o método <code class="language-plaintext highlighter-rouge">extensionViewDidAppear:</code> propriamente dito:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma mark - viewDidAppear: extension
</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">extensionViewDidAppear</span><span class="p">:(</span><span class="n">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
    
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"The view of viewController %@ appeared"</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
    
    <span class="p">[</span><span class="n">self</span> <span class="nf">extensionViewDidAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Lembre-se que após terminar a implementação é preciso chamar o método original. Isto será feito ao escrever <code class="language-plaintext highlighter-rouge">[self extensionViewDidAppear:]</code>.</p>

<p>Para finalizar, é necessário chamar o método <code class="language-plaintext highlighter-rouge">swizzlingViewDidAppear</code> no método <code class="language-plaintext highlighter-rouge">load</code>, que por sua vez é chamado assim que a classe for inicializada:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma mark - Load
</span>
<span class="k">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">load</span> <span class="p">{</span>
    
    <span class="k">static</span> <span class="n">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
    <span class="n">dispatch_once</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        
        <span class="p">[</span><span class="n">self</span> <span class="nf">swizzlingViewDidAppear</span><span class="p">];</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Como o método Swizzling muda o estado global da classe é preciso garantir que o código seja executado apenas uma vez, e por isso está sendo utilizado <code class="language-plaintext highlighter-rouge">dispatch_once</code>.</p>

<h2 id="cuidados-a-serem-tomados">Cuidados a serem tomados</h2>

<p>Embora os conceitos acima forneçam ferramentas poderosas, deve-se tomar o máximo de cautela antes de aplicá-los. Além da maior parte do tempo não ser necessário usá-los explicitamente, não entender a fundo como o processo funciona, ou caso haja alguma modificação interna da linguagem, pode fazer com que o aplicativo quebre quando menos se espere. No caso do método Swizzling, há o problema de haver conflito com métodos com mesmo nome, além de tornar o código mais difícil de debugar. A dica final é: pense em todas as possibilidades antes de utilizar os exemplos citados acima.</p>


                <hr>

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/ios/2016/03/20/visual-format/" data-toggle="tooltip" data-placement="top" title="Auto Layout com Visual Format">&larr; Post Anterior</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/ios/2016/03/23/fastlane/" data-toggle="tooltip" data-placement="top" title="Fastlane">Próximo Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- Disqus Content -->

                <div id="disqus_thread">
                    <script>
                        /**
                        * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
                        * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
                        */

                        /*
                        var disqus_config = function () {
                            this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
                            this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                        };
                        */

                        (function() { // DON'T EDIT BELOW THIS LINE
                        var d = document, s = d.createElement('script');

                        s.src = '//equinocios.disqus.com/embed.js';

                        s.setAttribute('data-timestamp', +new Date());
                        (d.head || d.body).appendChild(s);
                        })();
                    </script>
                    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
                </div>

            </div>
        </div>
    </div>
</article>

<hr>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                </ul>
                <p class="copyright text-muted">A odisseia do puto — Raimundo Pessoa & Frederico Do</p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/clean-blog.min.js "></script>


</body>

</html>
